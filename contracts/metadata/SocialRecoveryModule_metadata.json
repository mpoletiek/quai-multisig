"{\"compiler\":{\"version\":\"0.8.22+commit.4fc1097e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"recoveryHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"guardian\",\"type\":\"address\"}],\"name\":\"RecoveryApproved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"recoveryHash\",\"type\":\"bytes32\"}],\"name\":\"RecoveryCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"recoveryHash\",\"type\":\"bytes32\"}],\"name\":\"RecoveryExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"recoveryHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"newOwners\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newThreshold\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"initiator\",\"type\":\"address\"}],\"name\":\"RecoveryInitiated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"guardians\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"recoveryPeriod\",\"type\":\"uint256\"}],\"name\":\"RecoverySetup\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"recoveryHash\",\"type\":\"bytes32\"}],\"name\":\"approveRecovery\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"recoveryHash\",\"type\":\"bytes32\"}],\"name\":\"cancelRecovery\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"recoveryHash\",\"type\":\"bytes32\"}],\"name\":\"executeRecovery\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"recoveryHash\",\"type\":\"bytes32\"}],\"name\":\"getRecovery\",\"outputs\":[{\"components\":[{\"internalType\":\"address[]\",\"name\":\"newOwners\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"newThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"approvalCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"executionTime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"executed\",\"type\":\"bool\"}],\"internalType\":\"struct SocialRecoveryModule.Recovery\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"getRecoveryConfig\",\"outputs\":[{\"components\":[{\"internalType\":\"address[]\",\"name\":\"guardians\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"recoveryPeriod\",\"type\":\"uint256\"}],\"internalType\":\"struct SocialRecoveryModule.RecoveryConfig\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"newOwners\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"newThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"getRecoveryHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"newOwners\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"newThreshold\",\"type\":\"uint256\"}],\"name\":\"getRecoveryHashForCurrentNonce\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"newOwners\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"newThreshold\",\"type\":\"uint256\"}],\"name\":\"initiateRecovery\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"guardian\",\"type\":\"address\"}],\"name\":\"isGuardian\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"recoveries\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"newThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"approvalCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"executionTime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"executed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"recoveryApprovals\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"recoveryConfigs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"recoveryPeriod\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"recoveryNonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"guardians\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"recoveryPeriod\",\"type\":\"uint256\"}],\"name\":\"setupRecovery\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Module for social recovery of multisig wallets\",\"kind\":\"dev\",\"methods\":{\"approveRecovery(address,bytes32)\":{\"params\":{\"recoveryHash\":\"Recovery hash\",\"wallet\":\"Multisig wallet address\"}},\"cancelRecovery(address,bytes32)\":{\"params\":{\"recoveryHash\":\"Recovery hash\",\"wallet\":\"Multisig wallet address\"}},\"executeRecovery(address,bytes32)\":{\"params\":{\"recoveryHash\":\"Recovery hash\",\"wallet\":\"Multisig wallet address\"}},\"getRecovery(address,bytes32)\":{\"params\":{\"recoveryHash\":\"Recovery hash\",\"wallet\":\"Wallet address\"},\"returns\":{\"_0\":\"recovery Recovery details\"}},\"getRecoveryConfig(address)\":{\"params\":{\"wallet\":\"Wallet address\"},\"returns\":{\"_0\":\"config Recovery configuration\"}},\"getRecoveryHash(address,address[],uint256,uint256)\":{\"params\":{\"newOwners\":\"New owners\",\"newThreshold\":\"New threshold\",\"wallet\":\"Wallet address\"},\"returns\":{\"_0\":\"Recovery hash\"}},\"getRecoveryHashForCurrentNonce(address,address[],uint256)\":{\"params\":{\"newOwners\":\"New owners\",\"newThreshold\":\"New threshold\",\"wallet\":\"Wallet address\"},\"returns\":{\"_0\":\"Recovery hash with current nonce\"}},\"initiateRecovery(address,address[],uint256)\":{\"params\":{\"newOwners\":\"New owners after recovery\",\"newThreshold\":\"New threshold after recovery\",\"wallet\":\"Multisig wallet address\"},\"returns\":{\"_0\":\"recoveryHash Hash of the recovery\"}},\"isGuardian(address,address)\":{\"params\":{\"guardian\":\"Address to check\",\"wallet\":\"Wallet address\"},\"returns\":{\"_0\":\"True if guardian\"}},\"setupRecovery(address,address[],uint256,uint256)\":{\"params\":{\"guardians\":\"Array of guardian addresses\",\"recoveryPeriod\":\"Time delay before recovery can be executed\",\"threshold\":\"Number of guardian approvals required\",\"wallet\":\"Multisig wallet address\"}}},\"title\":\"SocialRecoveryModule\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"approveRecovery(address,bytes32)\":{\"notice\":\"Approve a recovery\"},\"cancelRecovery(address,bytes32)\":{\"notice\":\"Cancel a recovery (can be done by any current owner)\"},\"executeRecovery(address,bytes32)\":{\"notice\":\"Execute recovery after threshold is met and time delay has passed\"},\"getRecovery(address,bytes32)\":{\"notice\":\"Get recovery details\"},\"getRecoveryConfig(address)\":{\"notice\":\"Get recovery configuration\"},\"getRecoveryHash(address,address[],uint256,uint256)\":{\"notice\":\"Get recovery hash\"},\"getRecoveryHashForCurrentNonce(address,address[],uint256)\":{\"notice\":\"Get recovery hash for current nonce (for frontend convenience)\"},\"initiateRecovery(address,address[],uint256)\":{\"notice\":\"Initiate recovery process\"},\"isGuardian(address,address)\":{\"notice\":\"Check if address is a guardian\"},\"setupRecovery(address,address[],uint256,uint256)\":{\"notice\":\"Set up recovery configuration\"}},\"notice\":\"Allows guardians to recover wallet access\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/modules/SocialRecoveryModule.sol\":\"SocialRecoveryModule\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```solidity\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n *\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Storage of the initializable contract.\\n     *\\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\\n     * when using with upgradeable contracts.\\n     *\\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\\n     */\\n    struct InitializableStorage {\\n        /**\\n         * @dev Indicates that the contract has been initialized.\\n         */\\n        uint64 _initialized;\\n        /**\\n         * @dev Indicates that the contract is in the process of being initialized.\\n         */\\n        bool _initializing;\\n    }\\n\\n    // keccak256(abi.encode(uint256(keccak256(\\\"openzeppelin.storage.Initializable\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\\n\\n    /**\\n     * @dev The contract is already initialized.\\n     */\\n    error InvalidInitialization();\\n\\n    /**\\n     * @dev The contract is not initializing.\\n     */\\n    error NotInitializing();\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint64 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\\n     * production.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        // Cache values to avoid duplicated sloads\\n        bool isTopLevelCall = !$._initializing;\\n        uint64 initialized = $._initialized;\\n\\n        // Allowed calls:\\n        // - initialSetup: the contract is not in the initializing state and no previous version was\\n        //                 initialized\\n        // - construction: the contract is initialized at version 1 (no reinitialization) and the\\n        //                 current contract is just being deployed\\n        bool initialSetup = initialized == 0 && isTopLevelCall;\\n        bool construction = initialized == 1 && address(this).code.length == 0;\\n\\n        if (!initialSetup && !construction) {\\n            revert InvalidInitialization();\\n        }\\n        $._initialized = 1;\\n        if (isTopLevelCall) {\\n            $._initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            $._initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint64 version) {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        if ($._initializing || $._initialized >= version) {\\n            revert InvalidInitialization();\\n        }\\n        $._initialized = version;\\n        $._initializing = true;\\n        _;\\n        $._initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        _checkInitializing();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\\n     */\\n    function _checkInitializing() internal view virtual {\\n        if (!_isInitializing()) {\\n            revert NotInitializing();\\n        }\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        if ($._initializing) {\\n            revert InvalidInitialization();\\n        }\\n        if ($._initialized != type(uint64).max) {\\n            $._initialized = type(uint64).max;\\n            emit Initialized(type(uint64).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint64) {\\n        return _getInitializableStorage()._initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _getInitializableStorage()._initializing;\\n    }\\n\\n    /**\\n     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\\n     *\\n     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\\n     */\\n    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\\n        return INITIALIZABLE_STORAGE;\\n    }\\n\\n    /**\\n     * @dev Returns a pointer to the storage namespace.\\n     */\\n    // solhint-disable-next-line var-name-mixedcase\\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\\n        bytes32 slot = _initializableStorageSlot();\\n        assembly {\\n            $.slot := slot\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xdb4d24ee2c087c391d587cd17adfe5b3f9d93b3110b1388c2ab6c7c0ad1dcd05\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.20;\\nimport {Initializable} from \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\\n * consider using {ReentrancyGuardTransient} instead.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuardUpgradeable is Initializable {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant NOT_ENTERED = 1;\\n    uint256 private constant ENTERED = 2;\\n\\n    /// @custom:storage-location erc7201:openzeppelin.storage.ReentrancyGuard\\n    struct ReentrancyGuardStorage {\\n        uint256 _status;\\n    }\\n\\n    // keccak256(abi.encode(uint256(keccak256(\\\"openzeppelin.storage.ReentrancyGuard\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant ReentrancyGuardStorageLocation = 0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\\n\\n    function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\\n        assembly {\\n            $.slot := ReentrancyGuardStorageLocation\\n        }\\n    }\\n\\n    /**\\n     * @dev Unauthorized reentrant call.\\n     */\\n    error ReentrancyGuardReentrantCall();\\n\\n    function __ReentrancyGuard_init() internal onlyInitializing {\\n        __ReentrancyGuard_init_unchained();\\n    }\\n\\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\\n        $._status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\\n        if ($._status == ENTERED) {\\n            revert ReentrancyGuardReentrantCall();\\n        }\\n\\n        // Any calls to nonReentrant after this point will fail\\n        $._status = ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        $._status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\\n        return $._status == ENTERED;\\n    }\\n}\\n\",\"keccak256\":\"0x361126a17677994081cd9cb69c3f50cffff6e920d25cb7e428acdb1ae41d1866\",\"license\":\"MIT\"},\"contracts/MultisigWallet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\\\";\\n\\n/**\\n * @title MultisigWallet\\n * @dev Core multisig wallet implementation with upgradeable proxy pattern\\n * @notice This is the implementation contract used by all proxy instances\\n */\\ncontract MultisigWallet is Initializable, ReentrancyGuardUpgradeable {\\n    // Transaction structure\\n    struct Transaction {\\n        address to;\\n        uint256 value;\\n        bytes data;\\n        bool executed;\\n        bool cancelled;\\n        uint256 numApprovals;\\n        uint256 timestamp;\\n        address proposer; // Track who proposed the transaction\\n    }\\n\\n    // State variables\\n    mapping(address => bool) public isOwner;\\n    address[] public owners;\\n    uint256 public threshold;\\n    uint256 public nonce;\\n\\n    mapping(bytes32 => Transaction) public transactions;\\n    mapping(bytes32 => mapping(address => bool)) public approvals;\\n    mapping(address => bool) public modules;\\n\\n    // Events\\n    event TransactionProposed(\\n        bytes32 indexed txHash,\\n        address indexed proposer,\\n        address indexed to,\\n        uint256 value,\\n        bytes data\\n    );\\n\\n    event TransactionApproved(\\n        bytes32 indexed txHash,\\n        address indexed approver\\n    );\\n\\n    event TransactionExecuted(\\n        bytes32 indexed txHash,\\n        address indexed executor\\n    );\\n\\n    event ApprovalRevoked(\\n        bytes32 indexed txHash,\\n        address indexed owner\\n    );\\n\\n    event TransactionCancelled(\\n        bytes32 indexed txHash,\\n        address indexed canceller\\n    );\\n\\n    event OwnerAdded(address indexed owner);\\n    event OwnerRemoved(address indexed owner);\\n    event ThresholdChanged(uint256 threshold);\\n    event ModuleEnabled(address indexed module);\\n    event ModuleDisabled(address indexed module);\\n    event Received(address indexed sender, uint256 amount);\\n\\n    // Modifiers\\n    modifier onlyOwner() {\\n        require(isOwner[msg.sender], \\\"Not an owner\\\");\\n        _;\\n    }\\n\\n    modifier onlySelf() {\\n        require(msg.sender == address(this), \\\"Only self\\\");\\n        _;\\n    }\\n\\n    modifier onlyModule() {\\n        require(modules[msg.sender], \\\"Not an authorized module\\\");\\n        _;\\n    }\\n\\n    modifier txExists(bytes32 txHash) {\\n        require(transactions[txHash].to != address(0), \\\"Transaction does not exist\\\");\\n        _;\\n    }\\n\\n    modifier notExecuted(bytes32 txHash) {\\n        require(!transactions[txHash].executed, \\\"Transaction already executed\\\");\\n        _;\\n    }\\n\\n    modifier notCancelled(bytes32 txHash) {\\n        require(!transactions[txHash].cancelled, \\\"Transaction already cancelled\\\");\\n        _;\\n    }\\n\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\n    constructor() {\\n        _disableInitializers();\\n    }\\n\\n    /**\\n     * @notice Initialize the multisig wallet\\n     * @param _owners Array of owner addresses\\n     * @param _threshold Number of required approvals\\n     */\\n    function initialize(\\n        address[] memory _owners,\\n        uint256 _threshold\\n    ) external initializer {\\n        require(_owners.length > 0, \\\"Owners required\\\");\\n        require(\\n            _threshold > 0 && _threshold <= _owners.length,\\n            \\\"Invalid threshold\\\"\\n        );\\n\\n        __ReentrancyGuard_init();\\n\\n        // Validate and set owners\\n        for (uint256 i = 0; i < _owners.length; i++) {\\n            address owner = _owners[i];\\n\\n            require(owner != address(0), \\\"Invalid owner address\\\");\\n            require(!isOwner[owner], \\\"Duplicate owner\\\");\\n\\n            isOwner[owner] = true;\\n            owners.push(owner);\\n        }\\n\\n        threshold = _threshold;\\n        nonce = 0;\\n    }\\n\\n    /**\\n     * @notice Propose a new transaction\\n     * @param to Destination address\\n     * @param value Amount of Quai to send\\n     * @param data Transaction data\\n     * @return txHash The transaction hash\\n     */\\n    function proposeTransaction(\\n        address to,\\n        uint256 value,\\n        bytes memory data\\n    ) external onlyOwner returns (bytes32) {\\n        require(to != address(0), \\\"Invalid destination address\\\");\\n\\n        bytes32 txHash = getTransactionHash(to, value, data, nonce);\\n\\n        // Check if transaction already exists\\n        Transaction storage existingTx = transactions[txHash];\\n        bool isOverwritingCancelled = false;\\n        \\n        // If transaction exists and is not cancelled, reject\\n        if (existingTx.to != address(0)) {\\n            require(existingTx.cancelled, \\\"Transaction already exists\\\");\\n            // If cancelled, we'll overwrite it below (treat as new proposal)\\n            isOverwritingCancelled = true;\\n        }\\n\\n        // If overwriting a cancelled transaction, clear all existing approvals\\n        // This is necessary because approveTransaction checks if an owner has already approved\\n        if (isOverwritingCancelled) {\\n            for (uint256 i = 0; i < owners.length; i++) {\\n                approvals[txHash][owners[i]] = false;\\n            }\\n        }\\n\\n        // Create or overwrite transaction (if it was cancelled)\\n        transactions[txHash] = Transaction({\\n            to: to,\\n            value: value,\\n            data: data,\\n            executed: false,\\n            cancelled: false,\\n            numApprovals: 0,\\n            timestamp: block.timestamp,\\n            proposer: msg.sender\\n        });\\n\\n        emit TransactionProposed(txHash, msg.sender, to, value, data);\\n\\n        return txHash;\\n    }\\n\\n    /**\\n     * @notice Approve a pending transaction\\n     * @param txHash Transaction hash to approve\\n     */\\n    function approveTransaction(bytes32 txHash)\\n        external\\n        onlyOwner\\n        txExists(txHash)\\n        notExecuted(txHash)\\n        notCancelled(txHash)\\n    {\\n        require(!approvals[txHash][msg.sender], \\\"Already approved\\\");\\n\\n        approvals[txHash][msg.sender] = true;\\n        transactions[txHash].numApprovals++;\\n\\n        emit TransactionApproved(txHash, msg.sender);\\n    }\\n\\n    /**\\n     * @notice Execute a transaction after threshold is met\\n     * @param txHash Transaction hash to execute\\n     */\\n    function executeTransaction(bytes32 txHash)\\n        external\\n        onlyOwner\\n        txExists(txHash)\\n        notExecuted(txHash)\\n        notCancelled(txHash)\\n        nonReentrant\\n    {\\n        Transaction storage transaction = transactions[txHash];\\n\\n        // Explicit check: cancelled transactions cannot be executed\\n        // (Defense-in-depth: modifier already checks this, but explicit for clarity)\\n        require(!transaction.cancelled, \\\"Transaction has been cancelled\\\");\\n\\n        require(\\n            transaction.numApprovals >= threshold,\\n            \\\"Not enough approvals\\\"\\n        );\\n\\n        transaction.executed = true;\\n        nonce++;\\n\\n        // Handle self-calls (owner management) differently to avoid reentrancy guard issues\\n        if (transaction.to == address(this)) {\\n            // For self-calls, decode and execute using internal functions\\n            // This avoids the reentrancy guard blocking external calls\\n            bytes4 selector = bytes4(transaction.data);\\n            \\n            if (selector == this.addOwner.selector) {\\n                // Decode addOwner(address)\\n                bytes memory dataSlice = new bytes(transaction.data.length - 4);\\n                for (uint256 i = 4; i < transaction.data.length; i++) {\\n                    dataSlice[i - 4] = transaction.data[i];\\n                }\\n                address newOwner = abi.decode(dataSlice, (address));\\n                _addOwner(newOwner);\\n            } else if (selector == this.removeOwner.selector) {\\n                // Decode removeOwner(address)\\n                bytes memory dataSlice = new bytes(transaction.data.length - 4);\\n                for (uint256 i = 4; i < transaction.data.length; i++) {\\n                    dataSlice[i - 4] = transaction.data[i];\\n                }\\n                address ownerToRemove = abi.decode(dataSlice, (address));\\n                _removeOwner(ownerToRemove);\\n            } else if (selector == this.changeThreshold.selector) {\\n                // Decode changeThreshold(uint256)\\n                bytes memory dataSlice = new bytes(transaction.data.length - 4);\\n                for (uint256 i = 4; i < transaction.data.length; i++) {\\n                    dataSlice[i - 4] = transaction.data[i];\\n                }\\n                uint256 newThreshold = abi.decode(dataSlice, (uint256));\\n                _changeThreshold(newThreshold);\\n            } else {\\n                // Unknown self-call function - try using call anyway\\n                (bool success, ) = transaction.to.call{value: transaction.value}(\\n                    transaction.data\\n                );\\n                require(success, \\\"Transaction execution failed\\\");\\n            }\\n        } else {\\n            // External call - use standard call mechanism\\n            (bool success, ) = transaction.to.call{value: transaction.value}(\\n                transaction.data\\n            );\\n            require(success, \\\"Transaction execution failed\\\");\\n        }\\n\\n        emit TransactionExecuted(txHash, msg.sender);\\n    }\\n\\n    /**\\n     * @notice Revoke approval for a pending transaction\\n     * @param txHash Transaction hash\\n     */\\n    function revokeApproval(bytes32 txHash)\\n        external\\n        onlyOwner\\n        txExists(txHash)\\n        notExecuted(txHash)\\n        notCancelled(txHash)\\n    {\\n        require(approvals[txHash][msg.sender], \\\"Not approved\\\");\\n\\n        approvals[txHash][msg.sender] = false;\\n        transactions[txHash].numApprovals--;\\n\\n        emit ApprovalRevoked(txHash, msg.sender);\\n    }\\n\\n    /**\\n     * @notice Cancel a pending transaction\\n     * @dev Can be cancelled by the proposer immediately, or by threshold approvals\\n     * @param txHash Transaction hash to cancel\\n     */\\n    function cancelTransaction(bytes32 txHash)\\n        external\\n        onlyOwner\\n        txExists(txHash)\\n        notExecuted(txHash)\\n        notCancelled(txHash)\\n    {\\n        Transaction storage transaction = transactions[txHash];\\n        \\n        // Check if caller is the proposer\\n        bool isProposer = transaction.proposer == msg.sender;\\n        \\n        // If not proposer, require threshold approvals\\n        if (!isProposer) {\\n            require(\\n                transaction.numApprovals >= threshold,\\n                \\\"Not proposer and not enough approvals to cancel\\\"\\n            );\\n        }\\n\\n        // Mark as cancelled\\n        transaction.cancelled = true;\\n\\n        // Clear all approvals (clean up state)\\n        // Note: We don't need to iterate through all owners since approvals mapping\\n        // will just be ignored for cancelled transactions, but we reset numApprovals\\n        // for clarity and potential gas savings in future reads\\n        transaction.numApprovals = 0;\\n\\n        emit TransactionCancelled(txHash, msg.sender);\\n    }\\n\\n    /**\\n     * @notice Internal function to add a new owner\\n     * @param owner Address of new owner\\n     */\\n    function _addOwner(address owner) internal {\\n        require(owner != address(0), \\\"Invalid owner address\\\");\\n        require(!isOwner[owner], \\\"Already an owner\\\");\\n\\n        isOwner[owner] = true;\\n        owners.push(owner);\\n\\n        emit OwnerAdded(owner);\\n    }\\n\\n    /**\\n     * @notice Add a new owner (requires multisig approval)\\n     * @param owner Address of new owner\\n     */\\n    function addOwner(address owner) external onlySelf {\\n        _addOwner(owner);\\n    }\\n\\n    /**\\n     * @notice Internal function to remove an owner\\n     * @param owner Address of owner to remove\\n     */\\n    function _removeOwner(address owner) internal {\\n        require(isOwner[owner], \\\"Not an owner\\\");\\n        require(owners.length - 1 >= threshold, \\\"Cannot remove owner: would fall below threshold\\\");\\n\\n        isOwner[owner] = false;\\n\\n        // Remove from owners array\\n        for (uint256 i = 0; i < owners.length; i++) {\\n            if (owners[i] == owner) {\\n                owners[i] = owners[owners.length - 1];\\n                owners.pop();\\n                break;\\n            }\\n        }\\n\\n        emit OwnerRemoved(owner);\\n    }\\n\\n    /**\\n     * @notice Remove an owner (requires multisig approval)\\n     * @param owner Address of owner to remove\\n     */\\n    function removeOwner(address owner) external onlySelf {\\n        _removeOwner(owner);\\n    }\\n\\n    /**\\n     * @notice Internal function to change the approval threshold\\n     * @param _threshold New threshold value\\n     */\\n    function _changeThreshold(uint256 _threshold) internal {\\n        require(\\n            _threshold > 0 && _threshold <= owners.length,\\n            \\\"Invalid threshold\\\"\\n        );\\n\\n        threshold = _threshold;\\n\\n        emit ThresholdChanged(_threshold);\\n    }\\n\\n    /**\\n     * @notice Change the approval threshold (requires multisig approval)\\n     * @param _threshold New threshold value\\n     */\\n    function changeThreshold(uint256 _threshold) external onlySelf {\\n        _changeThreshold(_threshold);\\n    }\\n\\n    /**\\n     * @notice Enable a module\\n     * @param module Module address to enable\\n     */\\n    function enableModule(address module) external onlySelf {\\n        require(module != address(0), \\\"Invalid module address\\\");\\n        require(!modules[module], \\\"Module already enabled\\\");\\n\\n        modules[module] = true;\\n\\n        emit ModuleEnabled(module);\\n    }\\n\\n    /**\\n     * @notice Disable a module\\n     * @param module Module address to disable\\n     */\\n    function disableModule(address module) external onlySelf {\\n        require(modules[module], \\\"Module not enabled\\\");\\n\\n        modules[module] = false;\\n\\n        emit ModuleDisabled(module);\\n    }\\n\\n    /**\\n     * @notice Execute transaction from authorized module\\n     * @param to Destination address\\n     * @param value Amount to send\\n     * @param data Transaction data\\n     */\\n    function execTransactionFromModule(\\n        address to,\\n        uint256 value,\\n        bytes memory data\\n    ) external onlyModule nonReentrant returns (bool) {\\n        require(to != address(0), \\\"Invalid destination address\\\");\\n\\n        (bool success, ) = to.call{value: value}(data);\\n        return success;\\n    }\\n\\n    /**\\n     * @notice Get transaction hash\\n     * @param to Destination address\\n     * @param value Amount\\n     * @param data Transaction data\\n     * @param _nonce Nonce value\\n     * @return Transaction hash\\n     */\\n    function getTransactionHash(\\n        address to,\\n        uint256 value,\\n        bytes memory data,\\n        uint256 _nonce\\n    ) public view returns (bytes32) {\\n        return keccak256(\\n            abi.encodePacked(\\n                address(this),\\n                to,\\n                value,\\n                data,\\n                _nonce,\\n                block.chainid\\n            )\\n        );\\n    }\\n\\n    /**\\n     * @notice Get all owners\\n     * @return Array of owner addresses\\n     */\\n    function getOwners() external view returns (address[] memory) {\\n        return owners;\\n    }\\n\\n    /**\\n     * @notice Get owner count\\n     * @return Number of owners\\n     */\\n    function getOwnerCount() external view returns (uint256) {\\n        return owners.length;\\n    }\\n\\n    /**\\n     * @notice Get transaction details\\n     * @param txHash Transaction hash\\n     * @return Transaction struct\\n     */\\n    function getTransaction(bytes32 txHash)\\n        external\\n        view\\n        returns (Transaction memory)\\n    {\\n        return transactions[txHash];\\n    }\\n\\n    /**\\n     * @notice Check if address has approved transaction\\n     * @param txHash Transaction hash\\n     * @param owner Owner address\\n     * @return True if approved\\n     */\\n    function hasApproved(bytes32 txHash, address owner)\\n        external\\n        view\\n        returns (bool)\\n    {\\n        return approvals[txHash][owner];\\n    }\\n\\n    /**\\n     * @notice Receive function to accept Quai\\n     */\\n    receive() external payable {\\n        emit Received(msg.sender, msg.value);\\n    }\\n\\n    /**\\n     * @notice Fallback function\\n     */\\n    fallback() external payable {\\n        emit Received(msg.sender, msg.value);\\n    }\\n}\\n\",\"keccak256\":\"0xc83b6fd34316603880041e0afebfb3ebca2b59ca83d27b12e4998a153e751f6f\",\"license\":\"MIT\"},\"contracts/modules/SocialRecoveryModule.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport \\\"../MultisigWallet.sol\\\";\\n\\n/**\\n * @title SocialRecoveryModule\\n * @dev Module for social recovery of multisig wallets\\n * @notice Allows guardians to recover wallet access\\n */\\ncontract SocialRecoveryModule {\\n    struct RecoveryConfig {\\n        address[] guardians;\\n        uint256 threshold;\\n        uint256 recoveryPeriod; // Time delay before execution\\n    }\\n\\n    struct Recovery {\\n        address[] newOwners;\\n        uint256 newThreshold;\\n        uint256 approvalCount;\\n        uint256 executionTime;\\n        bool executed;\\n    }\\n\\n    // Wallet => RecoveryConfig\\n    mapping(address => RecoveryConfig) public recoveryConfigs;\\n\\n    // Wallet => RecoveryHash => Recovery\\n    mapping(address => mapping(bytes32 => Recovery)) public recoveries;\\n\\n    // Wallet => RecoveryHash => Guardian => Approved\\n    mapping(address => mapping(bytes32 => mapping(address => bool))) public recoveryApprovals;\\n\\n    // Wallet => Nonce (incremented for each recovery initiation)\\n    mapping(address => uint256) public recoveryNonces;\\n\\n    // Events\\n    event RecoverySetup(\\n        address indexed wallet,\\n        address[] guardians,\\n        uint256 threshold,\\n        uint256 recoveryPeriod\\n    );\\n\\n    event RecoveryInitiated(\\n        address indexed wallet,\\n        bytes32 indexed recoveryHash,\\n        address[] newOwners,\\n        uint256 newThreshold,\\n        address indexed initiator\\n    );\\n\\n    event RecoveryApproved(\\n        address indexed wallet,\\n        bytes32 indexed recoveryHash,\\n        address indexed guardian\\n    );\\n\\n    event RecoveryExecuted(\\n        address indexed wallet,\\n        bytes32 indexed recoveryHash\\n    );\\n\\n    event RecoveryCancelled(\\n        address indexed wallet,\\n        bytes32 indexed recoveryHash\\n    );\\n\\n    /**\\n     * @notice Set up recovery configuration\\n     * @param wallet Multisig wallet address\\n     * @param guardians Array of guardian addresses\\n     * @param threshold Number of guardian approvals required\\n     * @param recoveryPeriod Time delay before recovery can be executed\\n     */\\n    function setupRecovery(\\n        address wallet,\\n        address[] memory guardians,\\n        uint256 threshold,\\n        uint256 recoveryPeriod\\n    ) external {\\n        MultisigWallet multisig = MultisigWallet(payable(wallet));\\n        require(multisig.isOwner(msg.sender), \\\"Not an owner\\\");\\n        require(guardians.length > 0, \\\"Guardians required\\\");\\n        require(\\n            threshold > 0 && threshold <= guardians.length,\\n            \\\"Invalid threshold\\\"\\n        );\\n        require(recoveryPeriod >= 1 days, \\\"Recovery period too short\\\");\\n\\n        // Validate guardians\\n        for (uint256 i = 0; i < guardians.length; i++) {\\n            require(guardians[i] != address(0), \\\"Invalid guardian address\\\");\\n            // Check for duplicates\\n            for (uint256 j = i + 1; j < guardians.length; j++) {\\n                require(guardians[i] != guardians[j], \\\"Duplicate guardian\\\");\\n            }\\n        }\\n\\n        recoveryConfigs[wallet] = RecoveryConfig({\\n            guardians: guardians,\\n            threshold: threshold,\\n            recoveryPeriod: recoveryPeriod\\n        });\\n\\n        emit RecoverySetup(wallet, guardians, threshold, recoveryPeriod);\\n    }\\n\\n    /**\\n     * @notice Initiate recovery process\\n     * @param wallet Multisig wallet address\\n     * @param newOwners New owners after recovery\\n     * @param newThreshold New threshold after recovery\\n     * @return recoveryHash Hash of the recovery\\n     */\\n    function initiateRecovery(\\n        address wallet,\\n        address[] memory newOwners,\\n        uint256 newThreshold\\n    ) external returns (bytes32) {\\n        RecoveryConfig memory config = recoveryConfigs[wallet];\\n        require(config.guardians.length > 0, \\\"Recovery not configured\\\");\\n        require(isGuardian(wallet, msg.sender), \\\"Not a guardian\\\");\\n        require(newOwners.length > 0, \\\"New owners required\\\");\\n        require(\\n            newThreshold > 0 && newThreshold <= newOwners.length,\\n            \\\"Invalid threshold\\\"\\n        );\\n\\n        // Increment nonce to ensure unique recovery hash\\n        recoveryNonces[wallet]++;\\n        uint256 nonce = recoveryNonces[wallet];\\n\\n        bytes32 recoveryHash = getRecoveryHash(wallet, newOwners, newThreshold, nonce);\\n\\n        // Check if recovery with this hash already exists (shouldn't happen with nonce, but safety check)\\n        require(\\n            recoveries[wallet][recoveryHash].executionTime == 0,\\n            \\\"Recovery already initiated\\\"\\n        );\\n\\n        recoveries[wallet][recoveryHash] = Recovery({\\n            newOwners: newOwners,\\n            newThreshold: newThreshold,\\n            approvalCount: 0,\\n            executionTime: block.timestamp + config.recoveryPeriod,\\n            executed: false\\n        });\\n\\n        emit RecoveryInitiated(\\n            wallet,\\n            recoveryHash,\\n            newOwners,\\n            newThreshold,\\n            msg.sender\\n        );\\n\\n        return recoveryHash;\\n    }\\n\\n    /**\\n     * @notice Approve a recovery\\n     * @param wallet Multisig wallet address\\n     * @param recoveryHash Recovery hash\\n     */\\n    function approveRecovery(address wallet, bytes32 recoveryHash) external {\\n        require(isGuardian(wallet, msg.sender), \\\"Not a guardian\\\");\\n        require(\\n            recoveries[wallet][recoveryHash].executionTime != 0,\\n            \\\"Recovery not initiated\\\"\\n        );\\n        require(\\n            !recoveries[wallet][recoveryHash].executed,\\n            \\\"Recovery already executed\\\"\\n        );\\n        require(\\n            !recoveryApprovals[wallet][recoveryHash][msg.sender],\\n            \\\"Already approved\\\"\\n        );\\n\\n        recoveryApprovals[wallet][recoveryHash][msg.sender] = true;\\n        recoveries[wallet][recoveryHash].approvalCount++;\\n\\n        emit RecoveryApproved(wallet, recoveryHash, msg.sender);\\n    }\\n\\n    /**\\n     * @notice Execute recovery after threshold is met and time delay has passed\\n     * @param wallet Multisig wallet address\\n     * @param recoveryHash Recovery hash\\n     */\\n    function executeRecovery(address wallet, bytes32 recoveryHash) external {\\n        RecoveryConfig memory config = recoveryConfigs[wallet];\\n        Recovery storage recovery = recoveries[wallet][recoveryHash];\\n\\n        require(recovery.executionTime != 0, \\\"Recovery not initiated\\\");\\n        require(!recovery.executed, \\\"Recovery already executed\\\");\\n        require(\\n            recovery.approvalCount >= config.threshold,\\n            \\\"Not enough approvals\\\"\\n        );\\n        require(\\n            block.timestamp >= recovery.executionTime,\\n            \\\"Recovery period not elapsed\\\"\\n        );\\n\\n        recovery.executed = true;\\n\\n        MultisigWallet multisig = MultisigWallet(payable(wallet));\\n\\n        // Remove old owners and add new owners\\n        address[] memory oldOwners = multisig.getOwners();\\n\\n        // Add new owners\\n        for (uint256 i = 0; i < recovery.newOwners.length; i++) {\\n            if (!multisig.isOwner(recovery.newOwners[i])) {\\n                multisig.addOwner(recovery.newOwners[i]);\\n            }\\n        }\\n\\n        // Remove old owners that are not in new owners list\\n        for (uint256 i = 0; i < oldOwners.length; i++) {\\n            bool keepOwner = false;\\n            for (uint256 j = 0; j < recovery.newOwners.length; j++) {\\n                if (oldOwners[i] == recovery.newOwners[j]) {\\n                    keepOwner = true;\\n                    break;\\n                }\\n            }\\n            if (!keepOwner) {\\n                multisig.removeOwner(oldOwners[i]);\\n            }\\n        }\\n\\n        // Update threshold\\n        multisig.changeThreshold(recovery.newThreshold);\\n\\n        emit RecoveryExecuted(wallet, recoveryHash);\\n    }\\n\\n    /**\\n     * @notice Cancel a recovery (can be done by any current owner)\\n     * @param wallet Multisig wallet address\\n     * @param recoveryHash Recovery hash\\n     */\\n    function cancelRecovery(address wallet, bytes32 recoveryHash) external {\\n        MultisigWallet multisig = MultisigWallet(payable(wallet));\\n        require(multisig.isOwner(msg.sender), \\\"Not an owner\\\");\\n\\n        Recovery storage recovery = recoveries[wallet][recoveryHash];\\n        require(recovery.executionTime != 0, \\\"Recovery not initiated\\\");\\n        require(!recovery.executed, \\\"Recovery already executed\\\");\\n\\n        delete recoveries[wallet][recoveryHash];\\n\\n        emit RecoveryCancelled(wallet, recoveryHash);\\n    }\\n\\n    /**\\n     * @notice Get recovery hash\\n     * @param wallet Wallet address\\n     * @param newOwners New owners\\n     * @param newThreshold New threshold\\n     * @return Recovery hash\\n     */\\n    function getRecoveryHash(\\n        address wallet,\\n        address[] memory newOwners,\\n        uint256 newThreshold,\\n        uint256 nonce\\n    ) public pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(wallet, newOwners, newThreshold, nonce));\\n    }\\n\\n    /**\\n     * @notice Get recovery hash for current nonce (for frontend convenience)\\n     * @param wallet Wallet address\\n     * @param newOwners New owners\\n     * @param newThreshold New threshold\\n     * @return Recovery hash with current nonce\\n     */\\n    function getRecoveryHashForCurrentNonce(\\n        address wallet,\\n        address[] memory newOwners,\\n        uint256 newThreshold\\n    ) public view returns (bytes32) {\\n        return getRecoveryHash(wallet, newOwners, newThreshold, recoveryNonces[wallet] + 1);\\n    }\\n\\n    /**\\n     * @notice Check if address is a guardian\\n     * @param wallet Wallet address\\n     * @param guardian Address to check\\n     * @return True if guardian\\n     */\\n    function isGuardian(address wallet, address guardian)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        RecoveryConfig memory config = recoveryConfigs[wallet];\\n        for (uint256 i = 0; i < config.guardians.length; i++) {\\n            if (config.guardians[i] == guardian) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    /**\\n     * @notice Get recovery configuration\\n     * @param wallet Wallet address\\n     * @return config Recovery configuration\\n     */\\n    function getRecoveryConfig(address wallet)\\n        external\\n        view\\n        returns (RecoveryConfig memory)\\n    {\\n        return recoveryConfigs[wallet];\\n    }\\n\\n    /**\\n     * @notice Get recovery details\\n     * @param wallet Wallet address\\n     * @param recoveryHash Recovery hash\\n     * @return recovery Recovery details\\n     */\\n    function getRecovery(address wallet, bytes32 recoveryHash)\\n        external\\n        view\\n        returns (Recovery memory)\\n    {\\n        return recoveries[wallet][recoveryHash];\\n    }\\n}\\n\",\"keccak256\":\"0xea0758710a4c37eb689c69b4f9ce333de850eb3470f5538049b7f33ac504a2d8\",\"license\":\"MIT\"}},\"version\":1}"