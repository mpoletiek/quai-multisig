"{\"compiler\":{\"version\":\"0.8.22+commit.4fc1097e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"AddressRemovedFromWhitelist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"AddressWhitelisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"WhitelistTransactionExecuted\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"addToWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"limits\",\"type\":\"uint256[]\"}],\"name\":\"batchAddToWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"executeToWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getWhitelistLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isWhitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"removeFromWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelistLimits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Module for whitelisting addresses that can receive funds without full approval\",\"events\":{\"AddressRemovedFromWhitelist(address,address)\":{\"params\":{\"addr\":\"Address being removed\",\"wallet\":\"Address of the multisig wallet\"}},\"AddressWhitelisted(address,address,uint256)\":{\"params\":{\"addr\":\"Address being whitelisted\",\"limit\":\"Maximum per-transaction amount (0 = unlimited)\",\"wallet\":\"Address of the multisig wallet\"}},\"WhitelistTransactionExecuted(address,address,uint256)\":{\"params\":{\"to\":\"Destination address\",\"value\":\"Amount sent in wei\",\"wallet\":\"Address of the multisig wallet\"}}},\"kind\":\"dev\",\"methods\":{\"addToWhitelist(address,address,uint256)\":{\"params\":{\"addr\":\"Address to whitelist\",\"limit\":\"Maximum amount that can be sent (0 = unlimited)\",\"wallet\":\"Multisig wallet address\"}},\"batchAddToWhitelist(address,address[],uint256[])\":{\"params\":{\"addresses\":\"Array of addresses to whitelist\",\"limits\":\"Array of limits (0 = unlimited)\",\"wallet\":\"Multisig wallet address\"}},\"executeToWhitelist(address,address,uint256,bytes)\":{\"params\":{\"data\":\"Transaction data\",\"to\":\"Whitelisted destination address\",\"value\":\"Amount to send\",\"wallet\":\"Multisig wallet address\"}},\"getWhitelistLimit(address,address)\":{\"params\":{\"addr\":\"Address to check\",\"wallet\":\"Multisig wallet address\"},\"returns\":{\"_0\":\"Limit (0 = unlimited or not whitelisted)\"}},\"isWhitelisted(address,address)\":{\"params\":{\"addr\":\"Address to check\",\"wallet\":\"Multisig wallet address\"},\"returns\":{\"_0\":\"True if whitelisted\"}},\"removeFromWhitelist(address,address)\":{\"params\":{\"addr\":\"Address to remove\",\"wallet\":\"Multisig wallet address\"}}},\"title\":\"WhitelistModule\",\"version\":1},\"userdoc\":{\"events\":{\"AddressRemovedFromWhitelist(address,address)\":{\"notice\":\"Emitted when an address is removed from the whitelist\"},\"AddressWhitelisted(address,address,uint256)\":{\"notice\":\"Emitted when an address is added to the whitelist\"},\"WhitelistTransactionExecuted(address,address,uint256)\":{\"notice\":\"Emitted when a transaction is executed to a whitelisted address\"}},\"kind\":\"user\",\"methods\":{\"addToWhitelist(address,address,uint256)\":{\"notice\":\"Add address to whitelist\"},\"batchAddToWhitelist(address,address[],uint256[])\":{\"notice\":\"Batch add addresses to whitelist\"},\"executeToWhitelist(address,address,uint256,bytes)\":{\"notice\":\"Execute transaction to whitelisted address\"},\"getWhitelistLimit(address,address)\":{\"notice\":\"Get whitelist limit for an address\"},\"isWhitelisted(address,address)\":{\"notice\":\"Check if address is whitelisted\"},\"removeFromWhitelist(address,address)\":{\"notice\":\"Remove address from whitelist\"},\"whitelist(address,address)\":{\"notice\":\"Mapping from wallet to address to whitelist status\"},\"whitelistLimits(address,address)\":{\"notice\":\"Mapping from wallet to address to per-transaction limit (0 = unlimited)\"}},\"notice\":\"Pre-approved addresses can be sent to with reduced friction\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/modules/WhitelistModule.sol\":\"WhitelistModule\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```solidity\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n *\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Storage of the initializable contract.\\n     *\\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\\n     * when using with upgradeable contracts.\\n     *\\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\\n     */\\n    struct InitializableStorage {\\n        /**\\n         * @dev Indicates that the contract has been initialized.\\n         */\\n        uint64 _initialized;\\n        /**\\n         * @dev Indicates that the contract is in the process of being initialized.\\n         */\\n        bool _initializing;\\n    }\\n\\n    // keccak256(abi.encode(uint256(keccak256(\\\"openzeppelin.storage.Initializable\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\\n\\n    /**\\n     * @dev The contract is already initialized.\\n     */\\n    error InvalidInitialization();\\n\\n    /**\\n     * @dev The contract is not initializing.\\n     */\\n    error NotInitializing();\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint64 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\\n     * production.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        // Cache values to avoid duplicated sloads\\n        bool isTopLevelCall = !$._initializing;\\n        uint64 initialized = $._initialized;\\n\\n        // Allowed calls:\\n        // - initialSetup: the contract is not in the initializing state and no previous version was\\n        //                 initialized\\n        // - construction: the contract is initialized at version 1 (no reinitialization) and the\\n        //                 current contract is just being deployed\\n        bool initialSetup = initialized == 0 && isTopLevelCall;\\n        bool construction = initialized == 1 && address(this).code.length == 0;\\n\\n        if (!initialSetup && !construction) {\\n            revert InvalidInitialization();\\n        }\\n        $._initialized = 1;\\n        if (isTopLevelCall) {\\n            $._initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            $._initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint64 version) {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        if ($._initializing || $._initialized >= version) {\\n            revert InvalidInitialization();\\n        }\\n        $._initialized = version;\\n        $._initializing = true;\\n        _;\\n        $._initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        _checkInitializing();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\\n     */\\n    function _checkInitializing() internal view virtual {\\n        if (!_isInitializing()) {\\n            revert NotInitializing();\\n        }\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        if ($._initializing) {\\n            revert InvalidInitialization();\\n        }\\n        if ($._initialized != type(uint64).max) {\\n            $._initialized = type(uint64).max;\\n            emit Initialized(type(uint64).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint64) {\\n        return _getInitializableStorage()._initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _getInitializableStorage()._initializing;\\n    }\\n\\n    /**\\n     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\\n     *\\n     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\\n     */\\n    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\\n        return INITIALIZABLE_STORAGE;\\n    }\\n\\n    /**\\n     * @dev Returns a pointer to the storage namespace.\\n     */\\n    // solhint-disable-next-line var-name-mixedcase\\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\\n        bytes32 slot = _initializableStorageSlot();\\n        assembly {\\n            $.slot := slot\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xdb4d24ee2c087c391d587cd17adfe5b3f9d93b3110b1388c2ab6c7c0ad1dcd05\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.20;\\nimport {Initializable} from \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\\n * consider using {ReentrancyGuardTransient} instead.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuardUpgradeable is Initializable {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant NOT_ENTERED = 1;\\n    uint256 private constant ENTERED = 2;\\n\\n    /// @custom:storage-location erc7201:openzeppelin.storage.ReentrancyGuard\\n    struct ReentrancyGuardStorage {\\n        uint256 _status;\\n    }\\n\\n    // keccak256(abi.encode(uint256(keccak256(\\\"openzeppelin.storage.ReentrancyGuard\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant ReentrancyGuardStorageLocation = 0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\\n\\n    function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\\n        assembly {\\n            $.slot := ReentrancyGuardStorageLocation\\n        }\\n    }\\n\\n    /**\\n     * @dev Unauthorized reentrant call.\\n     */\\n    error ReentrancyGuardReentrantCall();\\n\\n    function __ReentrancyGuard_init() internal onlyInitializing {\\n        __ReentrancyGuard_init_unchained();\\n    }\\n\\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\\n        $._status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\\n        if ($._status == ENTERED) {\\n            revert ReentrancyGuardReentrantCall();\\n        }\\n\\n        // Any calls to nonReentrant after this point will fail\\n        $._status = ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        $._status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\\n        return $._status == ENTERED;\\n    }\\n}\\n\",\"keccak256\":\"0x361126a17677994081cd9cb69c3f50cffff6e920d25cb7e428acdb1ae41d1866\",\"license\":\"MIT\"},\"contracts/MultisigWallet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\\\";\\n\\n/**\\n * @title MultisigWallet\\n * @dev Core multisig wallet implementation with upgradeable proxy pattern\\n * @notice This is the implementation contract used by all proxy instances\\n */\\ncontract MultisigWallet is Initializable, ReentrancyGuardUpgradeable {\\n    /// @notice Maximum number of owners allowed (prevents DoS from gas-intensive loops)\\n    uint256 public constant MAX_OWNERS = 50;\\n\\n    /// @notice Structure representing a multisig transaction\\n    /// @dev Stores all transaction details including approval state\\n    struct Transaction {\\n        /// @notice Destination address for the transaction\\n        address to;\\n        /// @notice Amount of QUAI to send\\n        uint256 value;\\n        /// @notice Calldata to execute at destination\\n        bytes data;\\n        /// @notice Whether the transaction has been executed\\n        bool executed;\\n        /// @notice Whether the transaction has been cancelled\\n        bool cancelled;\\n        /// @notice Current number of owner approvals\\n        uint256 numApprovals;\\n        /// @notice Block timestamp when transaction was proposed\\n        uint256 timestamp;\\n        /// @notice Address of the owner who proposed the transaction\\n        address proposer;\\n    }\\n\\n    /// @notice Mapping of address to owner status\\n    mapping(address => bool) public isOwner;\\n\\n    /// @notice Array of all owner addresses\\n    address[] public owners;\\n\\n    /// @notice Number of approvals required to execute a transaction\\n    uint256 public threshold;\\n\\n    /// @notice Transaction nonce used for hash generation\\n    uint256 public nonce;\\n\\n    /// @notice Mapping of transaction hash to transaction data\\n    mapping(bytes32 => Transaction) public transactions;\\n\\n    /// @notice Mapping of transaction hash to owner approvals\\n    mapping(bytes32 => mapping(address => bool)) public approvals;\\n\\n    /// @notice Mapping of enabled module addresses\\n    mapping(address => bool) public modules;\\n\\n    /// @notice Emitted when a new transaction is proposed\\n    /// @param txHash Unique hash identifying the transaction\\n    /// @param proposer Address of the owner who proposed the transaction\\n    /// @param to Destination address for the transaction\\n    /// @param value Amount of QUAI to send\\n    /// @param data Calldata to execute at destination\\n    event TransactionProposed(\\n        bytes32 indexed txHash,\\n        address indexed proposer,\\n        address indexed to,\\n        uint256 value,\\n        bytes data\\n    );\\n\\n    /// @notice Emitted when an owner approves a transaction\\n    /// @param txHash Hash of the approved transaction\\n    /// @param approver Address of the owner who approved\\n    event TransactionApproved(\\n        bytes32 indexed txHash,\\n        address indexed approver\\n    );\\n\\n    /// @notice Emitted when a transaction is successfully executed\\n    /// @param txHash Hash of the executed transaction\\n    /// @param executor Address of the owner who triggered execution\\n    event TransactionExecuted(\\n        bytes32 indexed txHash,\\n        address indexed executor\\n    );\\n\\n    /// @notice Emitted when an owner revokes their approval\\n    /// @param txHash Hash of the transaction\\n    /// @param owner Address of the owner who revoked approval\\n    event ApprovalRevoked(\\n        bytes32 indexed txHash,\\n        address indexed owner\\n    );\\n\\n    /// @notice Emitted when a transaction is cancelled\\n    /// @param txHash Hash of the cancelled transaction\\n    /// @param canceller Address of the owner who cancelled\\n    event TransactionCancelled(\\n        bytes32 indexed txHash,\\n        address indexed canceller\\n    );\\n\\n    /// @notice Emitted when a new owner is added to the wallet\\n    /// @param owner Address of the new owner\\n    event OwnerAdded(address indexed owner);\\n\\n    /// @notice Emitted when an owner is removed from the wallet\\n    /// @param owner Address of the removed owner\\n    event OwnerRemoved(address indexed owner);\\n\\n    /// @notice Emitted when the approval threshold is changed\\n    /// @param threshold New threshold value\\n    event ThresholdChanged(uint256 threshold);\\n\\n    /// @notice Emitted when a module is enabled\\n    /// @param module Address of the enabled module\\n    event ModuleEnabled(address indexed module);\\n\\n    /// @notice Emitted when a module is disabled\\n    /// @param module Address of the disabled module\\n    event ModuleDisabled(address indexed module);\\n\\n    /// @notice Emitted when the wallet receives QUAI\\n    /// @param sender Address that sent the QUAI\\n    /// @param amount Amount of QUAI received\\n    event Received(address indexed sender, uint256 amount);\\n\\n    /// @notice Restricts function access to wallet owners only\\n    modifier onlyOwner() {\\n        require(isOwner[msg.sender], \\\"Not an owner\\\");\\n        _;\\n    }\\n\\n    /// @notice Restricts function access to the wallet itself (for multisig-approved actions)\\n    modifier onlySelf() {\\n        require(msg.sender == address(this), \\\"Only self\\\");\\n        _;\\n    }\\n\\n    /// @notice Restricts function access to enabled modules only\\n    modifier onlyModule() {\\n        require(modules[msg.sender], \\\"Not an authorized module\\\");\\n        _;\\n    }\\n\\n    /// @notice Ensures the specified transaction exists\\n    /// @param txHash Transaction hash to check\\n    modifier txExists(bytes32 txHash) {\\n        require(transactions[txHash].to != address(0), \\\"Transaction does not exist\\\");\\n        _;\\n    }\\n\\n    /// @notice Ensures the specified transaction has not been executed\\n    /// @param txHash Transaction hash to check\\n    modifier notExecuted(bytes32 txHash) {\\n        require(!transactions[txHash].executed, \\\"Transaction already executed\\\");\\n        _;\\n    }\\n\\n    /// @notice Ensures the specified transaction has not been cancelled\\n    /// @param txHash Transaction hash to check\\n    modifier notCancelled(bytes32 txHash) {\\n        require(!transactions[txHash].cancelled, \\\"Transaction already cancelled\\\");\\n        _;\\n    }\\n\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\n    constructor() {\\n        _disableInitializers();\\n    }\\n\\n    /**\\n     * @notice Initialize the multisig wallet\\n     * @param _owners Array of owner addresses\\n     * @param _threshold Number of required approvals\\n     */\\n    function initialize(\\n        address[] memory _owners,\\n        uint256 _threshold\\n    ) external initializer {\\n        require(_owners.length > 0, \\\"Owners required\\\");\\n        require(_owners.length <= MAX_OWNERS, \\\"Too many owners\\\");\\n        require(\\n            _threshold > 0 && _threshold <= _owners.length,\\n            \\\"Invalid threshold\\\"\\n        );\\n\\n        __ReentrancyGuard_init();\\n\\n        // Validate and set owners\\n        for (uint256 i = 0; i < _owners.length; i++) {\\n            address owner = _owners[i];\\n\\n            require(owner != address(0), \\\"Invalid owner address\\\");\\n            require(!isOwner[owner], \\\"Duplicate owner\\\");\\n\\n            isOwner[owner] = true;\\n            owners.push(owner);\\n        }\\n\\n        threshold = _threshold;\\n        nonce = 0;\\n    }\\n\\n    /**\\n     * @notice Propose a new transaction\\n     * @param to Destination address\\n     * @param value Amount of Quai to send\\n     * @param data Transaction data\\n     * @return txHash The transaction hash\\n     */\\n    function proposeTransaction(\\n        address to,\\n        uint256 value,\\n        bytes memory data\\n    ) external onlyOwner returns (bytes32) {\\n        require(to != address(0), \\\"Invalid destination address\\\");\\n\\n        bytes32 txHash = getTransactionHash(to, value, data, nonce);\\n\\n        // Check if transaction already exists\\n        Transaction storage existingTx = transactions[txHash];\\n        bool isOverwritingCancelled = false;\\n        \\n        // If transaction exists and is not cancelled, reject\\n        if (existingTx.to != address(0)) {\\n            require(existingTx.cancelled, \\\"Transaction already exists\\\");\\n            // If cancelled, we'll overwrite it below (treat as new proposal)\\n            isOverwritingCancelled = true;\\n        }\\n\\n        // If overwriting a cancelled transaction, clear all existing approvals\\n        // This is necessary because approveTransaction checks if an owner has already approved\\n        if (isOverwritingCancelled) {\\n            for (uint256 i = 0; i < owners.length; i++) {\\n                approvals[txHash][owners[i]] = false;\\n            }\\n        }\\n\\n        // Create or overwrite transaction (if it was cancelled)\\n        transactions[txHash] = Transaction({\\n            to: to,\\n            value: value,\\n            data: data,\\n            executed: false,\\n            cancelled: false,\\n            numApprovals: 0,\\n            timestamp: block.timestamp,\\n            proposer: msg.sender\\n        });\\n\\n        // Increment nonce on proposal to prevent hash collisions\\n        // This ensures each proposal gets a unique hash even if cancelled and re-proposed\\n        nonce++;\\n\\n        emit TransactionProposed(txHash, msg.sender, to, value, data);\\n\\n        return txHash;\\n    }\\n\\n    /**\\n     * @notice Approve a pending transaction\\n     * @param txHash Transaction hash to approve\\n     */\\n    function approveTransaction(bytes32 txHash)\\n        external\\n        onlyOwner\\n        txExists(txHash)\\n        notExecuted(txHash)\\n        notCancelled(txHash)\\n    {\\n        require(!approvals[txHash][msg.sender], \\\"Already approved\\\");\\n\\n        approvals[txHash][msg.sender] = true;\\n        transactions[txHash].numApprovals++;\\n\\n        emit TransactionApproved(txHash, msg.sender);\\n    }\\n\\n    /**\\n     * @notice Approve and execute a transaction in one call if threshold is met\\n     * @dev Prevents frontrunning by combining approval and execution atomically\\n     * @param txHash Transaction hash to approve and potentially execute\\n     * @return executed Whether the transaction was executed\\n     */\\n    function approveAndExecute(bytes32 txHash)\\n        external\\n        onlyOwner\\n        txExists(txHash)\\n        notExecuted(txHash)\\n        notCancelled(txHash)\\n        nonReentrant\\n        returns (bool executed)\\n    {\\n        // First, approve if not already approved\\n        if (!approvals[txHash][msg.sender]) {\\n            approvals[txHash][msg.sender] = true;\\n            transactions[txHash].numApprovals++;\\n            emit TransactionApproved(txHash, msg.sender);\\n        }\\n\\n        // Check if threshold is met\\n        Transaction storage transaction = transactions[txHash];\\n        if (transaction.numApprovals >= threshold) {\\n            // Execute the transaction\\n            transaction.executed = true;\\n\\n            // Handle self-calls (owner management) differently\\n            if (transaction.to == address(this)) {\\n                bytes4 selector = bytes4(transaction.data);\\n\\n                if (selector == this.addOwner.selector) {\\n                    bytes memory dataSlice = new bytes(transaction.data.length - 4);\\n                    for (uint256 i = 4; i < transaction.data.length; i++) {\\n                        dataSlice[i - 4] = transaction.data[i];\\n                    }\\n                    address newOwner = abi.decode(dataSlice, (address));\\n                    _addOwner(newOwner);\\n                } else if (selector == this.removeOwner.selector) {\\n                    bytes memory dataSlice = new bytes(transaction.data.length - 4);\\n                    for (uint256 i = 4; i < transaction.data.length; i++) {\\n                        dataSlice[i - 4] = transaction.data[i];\\n                    }\\n                    address ownerToRemove = abi.decode(dataSlice, (address));\\n                    _removeOwner(ownerToRemove);\\n                } else if (selector == this.changeThreshold.selector) {\\n                    bytes memory dataSlice = new bytes(transaction.data.length - 4);\\n                    for (uint256 i = 4; i < transaction.data.length; i++) {\\n                        dataSlice[i - 4] = transaction.data[i];\\n                    }\\n                    uint256 newThreshold = abi.decode(dataSlice, (uint256));\\n                    _changeThreshold(newThreshold);\\n                } else {\\n                    (bool success, ) = transaction.to.call{value: transaction.value}(\\n                        transaction.data\\n                    );\\n                    require(success, \\\"Transaction execution failed\\\");\\n                }\\n            } else {\\n                (bool success, ) = transaction.to.call{value: transaction.value}(\\n                    transaction.data\\n                );\\n                require(success, \\\"Transaction execution failed\\\");\\n            }\\n\\n            emit TransactionExecuted(txHash, msg.sender);\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    /**\\n     * @notice Execute a transaction after threshold is met\\n     * @param txHash Transaction hash to execute\\n     */\\n    function executeTransaction(bytes32 txHash)\\n        external\\n        onlyOwner\\n        txExists(txHash)\\n        notExecuted(txHash)\\n        notCancelled(txHash)\\n        nonReentrant\\n    {\\n        Transaction storage transaction = transactions[txHash];\\n\\n        // Explicit check: cancelled transactions cannot be executed\\n        // (Defense-in-depth: modifier already checks this, but explicit for clarity)\\n        require(!transaction.cancelled, \\\"Transaction has been cancelled\\\");\\n\\n        require(\\n            transaction.numApprovals >= threshold,\\n            \\\"Not enough approvals\\\"\\n        );\\n\\n        transaction.executed = true;\\n\\n        // Handle self-calls (owner management) differently to avoid reentrancy guard issues\\n        if (transaction.to == address(this)) {\\n            // For self-calls, decode and execute using internal functions\\n            // This avoids the reentrancy guard blocking external calls\\n            bytes4 selector = bytes4(transaction.data);\\n            \\n            if (selector == this.addOwner.selector) {\\n                // Decode addOwner(address)\\n                bytes memory dataSlice = new bytes(transaction.data.length - 4);\\n                for (uint256 i = 4; i < transaction.data.length; i++) {\\n                    dataSlice[i - 4] = transaction.data[i];\\n                }\\n                address newOwner = abi.decode(dataSlice, (address));\\n                _addOwner(newOwner);\\n            } else if (selector == this.removeOwner.selector) {\\n                // Decode removeOwner(address)\\n                bytes memory dataSlice = new bytes(transaction.data.length - 4);\\n                for (uint256 i = 4; i < transaction.data.length; i++) {\\n                    dataSlice[i - 4] = transaction.data[i];\\n                }\\n                address ownerToRemove = abi.decode(dataSlice, (address));\\n                _removeOwner(ownerToRemove);\\n            } else if (selector == this.changeThreshold.selector) {\\n                // Decode changeThreshold(uint256)\\n                bytes memory dataSlice = new bytes(transaction.data.length - 4);\\n                for (uint256 i = 4; i < transaction.data.length; i++) {\\n                    dataSlice[i - 4] = transaction.data[i];\\n                }\\n                uint256 newThreshold = abi.decode(dataSlice, (uint256));\\n                _changeThreshold(newThreshold);\\n            } else {\\n                // Unknown self-call function - try using call anyway\\n                (bool success, ) = transaction.to.call{value: transaction.value}(\\n                    transaction.data\\n                );\\n                require(success, \\\"Transaction execution failed\\\");\\n            }\\n        } else {\\n            // External call - use standard call mechanism\\n            (bool success, ) = transaction.to.call{value: transaction.value}(\\n                transaction.data\\n            );\\n            require(success, \\\"Transaction execution failed\\\");\\n        }\\n\\n        emit TransactionExecuted(txHash, msg.sender);\\n    }\\n\\n    /**\\n     * @notice Revoke approval for a pending transaction\\n     * @param txHash Transaction hash\\n     */\\n    function revokeApproval(bytes32 txHash)\\n        external\\n        onlyOwner\\n        txExists(txHash)\\n        notExecuted(txHash)\\n        notCancelled(txHash)\\n    {\\n        require(approvals[txHash][msg.sender], \\\"Not approved\\\");\\n\\n        approvals[txHash][msg.sender] = false;\\n        transactions[txHash].numApprovals--;\\n\\n        emit ApprovalRevoked(txHash, msg.sender);\\n    }\\n\\n    /**\\n     * @notice Cancel a pending transaction\\n     * @dev Can be cancelled by the proposer immediately, or by threshold approvals\\n     * @param txHash Transaction hash to cancel\\n     */\\n    function cancelTransaction(bytes32 txHash)\\n        external\\n        onlyOwner\\n        txExists(txHash)\\n        notExecuted(txHash)\\n        notCancelled(txHash)\\n    {\\n        Transaction storage transaction = transactions[txHash];\\n        \\n        // Check if caller is the proposer\\n        bool isProposer = transaction.proposer == msg.sender;\\n        \\n        // If not proposer, require threshold approvals\\n        if (!isProposer) {\\n            require(\\n                transaction.numApprovals >= threshold,\\n                \\\"Not proposer and not enough approvals to cancel\\\"\\n            );\\n        }\\n\\n        // Mark as cancelled\\n        transaction.cancelled = true;\\n\\n        // Clear all approvals (clean up state)\\n        // Note: We don't need to iterate through all owners since approvals mapping\\n        // will just be ignored for cancelled transactions, but we reset numApprovals\\n        // for clarity and potential gas savings in future reads\\n        transaction.numApprovals = 0;\\n\\n        emit TransactionCancelled(txHash, msg.sender);\\n    }\\n\\n    /**\\n     * @notice Internal function to add a new owner\\n     * @param owner Address of new owner\\n     */\\n    function _addOwner(address owner) internal {\\n        require(owner != address(0), \\\"Invalid owner address\\\");\\n        require(!isOwner[owner], \\\"Already an owner\\\");\\n        require(owners.length < MAX_OWNERS, \\\"Max owners reached\\\");\\n\\n        isOwner[owner] = true;\\n        owners.push(owner);\\n\\n        emit OwnerAdded(owner);\\n    }\\n\\n    /**\\n     * @notice Add a new owner (requires multisig approval)\\n     * @param owner Address of new owner\\n     */\\n    function addOwner(address owner) external onlySelf {\\n        _addOwner(owner);\\n    }\\n\\n    /**\\n     * @notice Internal function to remove an owner\\n     * @param owner Address of owner to remove\\n     */\\n    function _removeOwner(address owner) internal {\\n        require(isOwner[owner], \\\"Not an owner\\\");\\n        require(owners.length - 1 >= threshold, \\\"Cannot remove owner: would fall below threshold\\\");\\n\\n        isOwner[owner] = false;\\n\\n        // Remove from owners array\\n        for (uint256 i = 0; i < owners.length; i++) {\\n            if (owners[i] == owner) {\\n                owners[i] = owners[owners.length - 1];\\n                owners.pop();\\n                break;\\n            }\\n        }\\n\\n        emit OwnerRemoved(owner);\\n    }\\n\\n    /**\\n     * @notice Remove an owner (requires multisig approval)\\n     * @param owner Address of owner to remove\\n     */\\n    function removeOwner(address owner) external onlySelf {\\n        _removeOwner(owner);\\n    }\\n\\n    /**\\n     * @notice Internal function to change the approval threshold\\n     * @param _threshold New threshold value\\n     */\\n    function _changeThreshold(uint256 _threshold) internal {\\n        require(\\n            _threshold > 0 && _threshold <= owners.length,\\n            \\\"Invalid threshold\\\"\\n        );\\n\\n        threshold = _threshold;\\n\\n        emit ThresholdChanged(_threshold);\\n    }\\n\\n    /**\\n     * @notice Change the approval threshold (requires multisig approval)\\n     * @param _threshold New threshold value\\n     */\\n    function changeThreshold(uint256 _threshold) external onlySelf {\\n        _changeThreshold(_threshold);\\n    }\\n\\n    /**\\n     * @notice Enable a module\\n     * @param module Module address to enable\\n     */\\n    function enableModule(address module) external onlySelf {\\n        require(module != address(0), \\\"Invalid module address\\\");\\n        require(!modules[module], \\\"Module already enabled\\\");\\n\\n        modules[module] = true;\\n\\n        emit ModuleEnabled(module);\\n    }\\n\\n    /**\\n     * @notice Disable a module\\n     * @param module Module address to disable\\n     */\\n    function disableModule(address module) external onlySelf {\\n        require(modules[module], \\\"Module not enabled\\\");\\n\\n        modules[module] = false;\\n\\n        emit ModuleDisabled(module);\\n    }\\n\\n    /**\\n     * @notice Execute transaction from authorized module\\n     * @dev Modules cannot call enableModule/disableModule (prevents privilege escalation)\\n     *      Owner management functions (addOwner, removeOwner, changeThreshold) are allowed\\n     *      for legitimate use cases like social recovery\\n     * @param to Destination address\\n     * @param value Amount to send\\n     * @param data Transaction data\\n     */\\n    function execTransactionFromModule(\\n        address to,\\n        uint256 value,\\n        bytes memory data\\n    ) external onlyModule nonReentrant returns (bool) {\\n        require(to != address(0), \\\"Invalid destination address\\\");\\n\\n        // Security: Prevent modules from modifying module permissions\\n        // This prevents a compromised module from enabling/disabling other modules\\n        // Owner management functions ARE allowed for legitimate recovery scenarios\\n        if (to == address(this) && data.length >= 4) {\\n            bytes4 selector = bytes4(data);\\n            require(\\n                selector != this.enableModule.selector &&\\n                selector != this.disableModule.selector,\\n                \\\"Module cannot modify module permissions\\\"\\n            );\\n        }\\n\\n        (bool success, ) = to.call{value: value}(data);\\n        return success;\\n    }\\n\\n    /**\\n     * @notice Get transaction hash\\n     * @param to Destination address\\n     * @param value Amount\\n     * @param data Transaction data\\n     * @param _nonce Nonce value\\n     * @return Transaction hash\\n     */\\n    function getTransactionHash(\\n        address to,\\n        uint256 value,\\n        bytes memory data,\\n        uint256 _nonce\\n    ) public view returns (bytes32) {\\n        return keccak256(\\n            abi.encodePacked(\\n                address(this),\\n                to,\\n                value,\\n                data,\\n                _nonce,\\n                block.chainid\\n            )\\n        );\\n    }\\n\\n    /**\\n     * @notice Get all owners\\n     * @return Array of owner addresses\\n     */\\n    function getOwners() external view returns (address[] memory) {\\n        return owners;\\n    }\\n\\n    /**\\n     * @notice Get owner count\\n     * @return Number of owners\\n     */\\n    function getOwnerCount() external view returns (uint256) {\\n        return owners.length;\\n    }\\n\\n    /**\\n     * @notice Get transaction details\\n     * @param txHash Transaction hash\\n     * @return Transaction struct\\n     */\\n    function getTransaction(bytes32 txHash)\\n        external\\n        view\\n        returns (Transaction memory)\\n    {\\n        return transactions[txHash];\\n    }\\n\\n    /**\\n     * @notice Check if address has approved transaction\\n     * @param txHash Transaction hash\\n     * @param owner Owner address\\n     * @return True if approved\\n     */\\n    function hasApproved(bytes32 txHash, address owner)\\n        external\\n        view\\n        returns (bool)\\n    {\\n        return approvals[txHash][owner];\\n    }\\n\\n    /**\\n     * @notice Receive function to accept Quai\\n     */\\n    receive() external payable {\\n        emit Received(msg.sender, msg.value);\\n    }\\n\\n    /**\\n     * @notice Fallback function\\n     */\\n    fallback() external payable {\\n        emit Received(msg.sender, msg.value);\\n    }\\n}\\n\",\"keccak256\":\"0xacf0eee249c4addad8fb5c895abb528e5086301c10e0770507a828b80099291a\",\"license\":\"MIT\"},\"contracts/modules/WhitelistModule.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport \\\"../MultisigWallet.sol\\\";\\n\\n/**\\n * @title WhitelistModule\\n * @dev Module for whitelisting addresses that can receive funds without full approval\\n * @notice Pre-approved addresses can be sent to with reduced friction\\n */\\ncontract WhitelistModule {\\n    /// @notice Mapping from wallet to address to whitelist status\\n    mapping(address => mapping(address => bool)) public whitelist;\\n\\n    /// @notice Mapping from wallet to address to per-transaction limit (0 = unlimited)\\n    mapping(address => mapping(address => uint256)) public whitelistLimits;\\n\\n    /// @notice Emitted when an address is added to the whitelist\\n    /// @param wallet Address of the multisig wallet\\n    /// @param addr Address being whitelisted\\n    /// @param limit Maximum per-transaction amount (0 = unlimited)\\n    event AddressWhitelisted(\\n        address indexed wallet,\\n        address indexed addr,\\n        uint256 limit\\n    );\\n\\n    /// @notice Emitted when an address is removed from the whitelist\\n    /// @param wallet Address of the multisig wallet\\n    /// @param addr Address being removed\\n    event AddressRemovedFromWhitelist(\\n        address indexed wallet,\\n        address indexed addr\\n    );\\n\\n    /// @notice Emitted when a transaction is executed to a whitelisted address\\n    /// @param wallet Address of the multisig wallet\\n    /// @param to Destination address\\n    /// @param value Amount sent in wei\\n    event WhitelistTransactionExecuted(\\n        address indexed wallet,\\n        address indexed to,\\n        uint256 value\\n    );\\n\\n    /**\\n     * @notice Add address to whitelist\\n     * @param wallet Multisig wallet address\\n     * @param addr Address to whitelist\\n     * @param limit Maximum amount that can be sent (0 = unlimited)\\n     */\\n    function addToWhitelist(\\n        address wallet,\\n        address addr,\\n        uint256 limit\\n    ) external {\\n        MultisigWallet multisig = MultisigWallet(payable(wallet));\\n        require(multisig.isOwner(msg.sender), \\\"Not an owner\\\");\\n        require(multisig.modules(address(this)), \\\"Module not enabled\\\");\\n        require(addr != address(0), \\\"Invalid address\\\");\\n\\n        whitelist[wallet][addr] = true;\\n        whitelistLimits[wallet][addr] = limit;\\n\\n        emit AddressWhitelisted(wallet, addr, limit);\\n    }\\n\\n    /**\\n     * @notice Remove address from whitelist\\n     * @param wallet Multisig wallet address\\n     * @param addr Address to remove\\n     */\\n    function removeFromWhitelist(address wallet, address addr) external {\\n        MultisigWallet multisig = MultisigWallet(payable(wallet));\\n        require(multisig.isOwner(msg.sender), \\\"Not an owner\\\");\\n\\n        whitelist[wallet][addr] = false;\\n        whitelistLimits[wallet][addr] = 0;\\n\\n        emit AddressRemovedFromWhitelist(wallet, addr);\\n    }\\n\\n    /**\\n     * @notice Execute transaction to whitelisted address\\n     * @param wallet Multisig wallet address\\n     * @param to Whitelisted destination address\\n     * @param value Amount to send\\n     * @param data Transaction data\\n     */\\n    function executeToWhitelist(\\n        address wallet,\\n        address to,\\n        uint256 value,\\n        bytes memory data\\n    ) external {\\n        MultisigWallet multisig = MultisigWallet(payable(wallet));\\n        require(multisig.isOwner(msg.sender), \\\"Not an owner\\\");\\n        require(multisig.modules(address(this)), \\\"Module not enabled\\\");\\n        require(whitelist[wallet][to], \\\"Address not whitelisted\\\");\\n\\n        // Check limit if set\\n        uint256 limit = whitelistLimits[wallet][to];\\n        if (limit > 0) {\\n            require(value <= limit, \\\"Exceeds whitelist limit\\\");\\n        }\\n\\n        // Execute transaction through wallet\\n        bool success = multisig.execTransactionFromModule(to, value, data);\\n        require(success, \\\"Transaction failed\\\");\\n\\n        emit WhitelistTransactionExecuted(wallet, to, value);\\n    }\\n\\n    /**\\n     * @notice Batch add addresses to whitelist\\n     * @param wallet Multisig wallet address\\n     * @param addresses Array of addresses to whitelist\\n     * @param limits Array of limits (0 = unlimited)\\n     */\\n    function batchAddToWhitelist(\\n        address wallet,\\n        address[] memory addresses,\\n        uint256[] memory limits\\n    ) external {\\n        require(addresses.length == limits.length, \\\"Array length mismatch\\\");\\n\\n        MultisigWallet multisig = MultisigWallet(payable(wallet));\\n        require(multisig.isOwner(msg.sender), \\\"Not an owner\\\");\\n        require(multisig.modules(address(this)), \\\"Module not enabled\\\");\\n\\n        for (uint256 i = 0; i < addresses.length; i++) {\\n            require(addresses[i] != address(0), \\\"Invalid address\\\");\\n\\n            whitelist[wallet][addresses[i]] = true;\\n            whitelistLimits[wallet][addresses[i]] = limits[i];\\n\\n            emit AddressWhitelisted(wallet, addresses[i], limits[i]);\\n        }\\n    }\\n\\n    /**\\n     * @notice Check if address is whitelisted\\n     * @param wallet Multisig wallet address\\n     * @param addr Address to check\\n     * @return True if whitelisted\\n     */\\n    function isWhitelisted(address wallet, address addr)\\n        external\\n        view\\n        returns (bool)\\n    {\\n        return whitelist[wallet][addr];\\n    }\\n\\n    /**\\n     * @notice Get whitelist limit for an address\\n     * @param wallet Multisig wallet address\\n     * @param addr Address to check\\n     * @return Limit (0 = unlimited or not whitelisted)\\n     */\\n    function getWhitelistLimit(address wallet, address addr)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return whitelistLimits[wallet][addr];\\n    }\\n}\\n\",\"keccak256\":\"0x28d437e70a3652a30c0c6c804492a99b6b337ef27103ba42ae6467e7deea744c\",\"license\":\"MIT\"}},\"version\":1}"