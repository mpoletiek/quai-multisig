"{\"compiler\":{\"version\":\"0.8.22+commit.4fc1097e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"DailyLimitNotSet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ExceedsDailyLimit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidDestination\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ModuleNotEnabled\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MustBeCalledByWallet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotAnOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransactionFailed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"DailyLimitReset\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"DailyLimitSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"remainingLimit\",\"type\":\"uint256\"}],\"name\":\"TransactionExecuted\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"dailyLimits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"spent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastReset\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"executeBelowLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"getDailyLimit\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"spent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastReset\",\"type\":\"uint256\"}],\"internalType\":\"struct DailyLimitModule.DailyLimit\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"getRemainingLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"getTimeUntilReset\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"resetDailyLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Module for setting daily spending limits on multisig wallets\",\"events\":{\"DailyLimitReset(address)\":{\"params\":{\"wallet\":\"Address of the multisig wallet\"}},\"DailyLimitSet(address,uint256)\":{\"params\":{\"limit\":\"New daily limit in wei\",\"wallet\":\"Address of the multisig wallet\"}},\"TransactionExecuted(address,address,uint256,uint256)\":{\"params\":{\"remainingLimit\":\"Remaining daily limit after transaction\",\"to\":\"Destination address\",\"value\":\"Amount sent in wei\",\"wallet\":\"Address of the multisig wallet\"}}},\"kind\":\"dev\",\"methods\":{\"executeBelowLimit(address,address,uint256)\":{\"params\":{\"to\":\"Destination address\",\"value\":\"Amount to send\",\"wallet\":\"Multisig wallet address\"}},\"getDailyLimit(address)\":{\"params\":{\"wallet\":\"Multisig wallet address\"},\"returns\":{\"_0\":\"Daily limit details\"}},\"getRemainingLimit(address)\":{\"params\":{\"wallet\":\"Multisig wallet address\"},\"returns\":{\"_0\":\"Remaining limit in wei\"}},\"getTimeUntilReset(address)\":{\"params\":{\"wallet\":\"Multisig wallet address\"},\"returns\":{\"_0\":\"Seconds until reset\"}},\"resetDailyLimit(address)\":{\"details\":\"SECURITY: Must be called through multisig transaction (msg.sender == wallet)      This prevents a single owner from unilaterally resetting the limit\",\"params\":{\"wallet\":\"Multisig wallet address\"}},\"setDailyLimit(address,uint256)\":{\"details\":\"SECURITY: Must be called through multisig transaction (msg.sender == wallet)      This prevents a single owner from unilaterally setting limits\",\"params\":{\"limit\":\"Daily limit in wei\",\"wallet\":\"Multisig wallet address\"}}},\"stateVariables\":{\"dailyLimits\":{\"details\":\"Each wallet has independent limit tracking; automatically resets after 24 hours from lastReset\"}},\"title\":\"DailyLimitModule\",\"version\":1},\"userdoc\":{\"events\":{\"DailyLimitReset(address)\":{\"notice\":\"Emitted when the daily limit is reset\"},\"DailyLimitSet(address,uint256)\":{\"notice\":\"Emitted when a daily limit is set or updated\"},\"TransactionExecuted(address,address,uint256,uint256)\":{\"notice\":\"Emitted when a transaction is executed within the daily limit\"}},\"kind\":\"user\",\"methods\":{\"dailyLimits(address)\":{\"notice\":\"Mapping from wallet address to its daily limit configuration\"},\"executeBelowLimit(address,address,uint256)\":{\"notice\":\"Execute transaction if below daily limit\"},\"getDailyLimit(address)\":{\"notice\":\"Get daily limit configuration\"},\"getRemainingLimit(address)\":{\"notice\":\"Get remaining daily limit\"},\"getTimeUntilReset(address)\":{\"notice\":\"Get time until limit resets\"},\"resetDailyLimit(address)\":{\"notice\":\"Manually reset daily limit\"},\"setDailyLimit(address,uint256)\":{\"notice\":\"Set daily spending limit\"}},\"notice\":\"Allows automatic execution of transactions below the daily limit\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/modules/DailyLimitModule.sol\":\"DailyLimitModule\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```solidity\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n *\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Storage of the initializable contract.\\n     *\\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\\n     * when using with upgradeable contracts.\\n     *\\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\\n     */\\n    struct InitializableStorage {\\n        /**\\n         * @dev Indicates that the contract has been initialized.\\n         */\\n        uint64 _initialized;\\n        /**\\n         * @dev Indicates that the contract is in the process of being initialized.\\n         */\\n        bool _initializing;\\n    }\\n\\n    // keccak256(abi.encode(uint256(keccak256(\\\"openzeppelin.storage.Initializable\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\\n\\n    /**\\n     * @dev The contract is already initialized.\\n     */\\n    error InvalidInitialization();\\n\\n    /**\\n     * @dev The contract is not initializing.\\n     */\\n    error NotInitializing();\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint64 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\\n     * production.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        // Cache values to avoid duplicated sloads\\n        bool isTopLevelCall = !$._initializing;\\n        uint64 initialized = $._initialized;\\n\\n        // Allowed calls:\\n        // - initialSetup: the contract is not in the initializing state and no previous version was\\n        //                 initialized\\n        // - construction: the contract is initialized at version 1 (no reinitialization) and the\\n        //                 current contract is just being deployed\\n        bool initialSetup = initialized == 0 && isTopLevelCall;\\n        bool construction = initialized == 1 && address(this).code.length == 0;\\n\\n        if (!initialSetup && !construction) {\\n            revert InvalidInitialization();\\n        }\\n        $._initialized = 1;\\n        if (isTopLevelCall) {\\n            $._initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            $._initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint64 version) {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        if ($._initializing || $._initialized >= version) {\\n            revert InvalidInitialization();\\n        }\\n        $._initialized = version;\\n        $._initializing = true;\\n        _;\\n        $._initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        _checkInitializing();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\\n     */\\n    function _checkInitializing() internal view virtual {\\n        if (!_isInitializing()) {\\n            revert NotInitializing();\\n        }\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        if ($._initializing) {\\n            revert InvalidInitialization();\\n        }\\n        if ($._initialized != type(uint64).max) {\\n            $._initialized = type(uint64).max;\\n            emit Initialized(type(uint64).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint64) {\\n        return _getInitializableStorage()._initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _getInitializableStorage()._initializing;\\n    }\\n\\n    /**\\n     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\\n     *\\n     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\\n     */\\n    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\\n        return INITIALIZABLE_STORAGE;\\n    }\\n\\n    /**\\n     * @dev Returns a pointer to the storage namespace.\\n     */\\n    // solhint-disable-next-line var-name-mixedcase\\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\\n        bytes32 slot = _initializableStorageSlot();\\n        assembly {\\n            $.slot := slot\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xdb4d24ee2c087c391d587cd17adfe5b3f9d93b3110b1388c2ab6c7c0ad1dcd05\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.20;\\nimport {Initializable} from \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\\n * consider using {ReentrancyGuardTransient} instead.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuardUpgradeable is Initializable {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant NOT_ENTERED = 1;\\n    uint256 private constant ENTERED = 2;\\n\\n    /// @custom:storage-location erc7201:openzeppelin.storage.ReentrancyGuard\\n    struct ReentrancyGuardStorage {\\n        uint256 _status;\\n    }\\n\\n    // keccak256(abi.encode(uint256(keccak256(\\\"openzeppelin.storage.ReentrancyGuard\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant ReentrancyGuardStorageLocation = 0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\\n\\n    function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\\n        assembly {\\n            $.slot := ReentrancyGuardStorageLocation\\n        }\\n    }\\n\\n    /**\\n     * @dev Unauthorized reentrant call.\\n     */\\n    error ReentrancyGuardReentrantCall();\\n\\n    function __ReentrancyGuard_init() internal onlyInitializing {\\n        __ReentrancyGuard_init_unchained();\\n    }\\n\\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\\n        $._status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\\n        if ($._status == ENTERED) {\\n            revert ReentrancyGuardReentrantCall();\\n        }\\n\\n        // Any calls to nonReentrant after this point will fail\\n        $._status = ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        $._status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\\n        return $._status == ENTERED;\\n    }\\n}\\n\",\"keccak256\":\"0x361126a17677994081cd9cb69c3f50cffff6e920d25cb7e428acdb1ae41d1866\",\"license\":\"MIT\"},\"contracts/MultisigWallet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\\\";\\n\\n/**\\n * @title MultisigWallet\\n * @dev Core multisig wallet implementation with upgradeable proxy pattern\\n * @notice This is the implementation contract used by all proxy instances\\n */\\ncontract MultisigWallet is Initializable, ReentrancyGuardUpgradeable {\\n    // Custom errors (gas efficient)\\n    error NotAnOwner();\\n    error OnlySelf();\\n    error NotAnAuthorizedModule();\\n    error TransactionDoesNotExist();\\n    error TransactionAlreadyExecuted();\\n    error TransactionAlreadyCancelled();\\n    error OwnersRequired();\\n    error TooManyOwners();\\n    error InvalidThreshold();\\n    error InvalidOwnerAddress();\\n    error DuplicateOwner();\\n    error InvalidDestinationAddress();\\n    error TransactionAlreadyExists();\\n    error AlreadyApproved();\\n    error TransactionExecutionFailed();\\n    error TransactionHasBeenCancelled();\\n    error NotEnoughApprovals();\\n    error NotApproved();\\n    error NotProposerAndNotEnoughApprovalsToCancel();\\n    error AlreadyAnOwner();\\n    error MaxOwnersReached();\\n    error CannotRemoveOwnerWouldFallBelowThreshold();\\n    error InvalidModuleAddress();\\n    error ModuleAlreadyEnabled();\\n    error ModuleNotEnabled();\\n    error ModuleCannotModifyModulePermissions();\\n\\n    /// @notice Maximum number of owners allowed (prevents DoS from gas-intensive loops)\\n    uint256 public constant MAX_OWNERS = 50;\\n\\n    /// @notice Structure representing a multisig transaction\\n    /// @dev Stores all transaction details including approval state\\n    struct Transaction {\\n        /// @notice Destination address for the transaction\\n        address to;\\n        /// @notice Amount of QUAI to send\\n        uint256 value;\\n        /// @notice Calldata to execute at destination\\n        bytes data;\\n        /// @notice Whether the transaction has been executed\\n        bool executed;\\n        /// @notice Whether the transaction has been cancelled\\n        bool cancelled;\\n        /// @notice Current number of owner approvals\\n        uint256 numApprovals;\\n        /// @notice Block timestamp when transaction was proposed\\n        uint256 timestamp;\\n        /// @notice Address of the owner who proposed the transaction\\n        address proposer;\\n    }\\n\\n    /// @notice Mapping of address to owner status\\n    /// @dev O(1) lookup for owner verification, more gas-efficient than iterating through owners array\\n    mapping(address => bool) public isOwner;\\n\\n    /// @notice Array of all owner addresses\\n    /// @dev Used for iteration when needed (e.g., clearing approvals), kept in sync with isOwner mapping\\n    address[] public owners;\\n\\n    /// @notice Number of approvals required to execute a transaction\\n    /// @dev Must satisfy: 1 <= threshold <= owners.length\\n    uint256 public threshold;\\n\\n    /// @notice Transaction nonce used for hash generation\\n    /// @dev Incremented on each proposal to ensure unique transaction hashes, prevents replay attacks\\n    uint256 public nonce;\\n\\n    /// @notice Mapping of transaction hash to transaction data\\n    /// @dev Uses bytes32 key instead of array for O(1) lookup and to support non-sequential proposals\\n    mapping(bytes32 => Transaction) public transactions;\\n\\n    /// @notice Mapping of transaction hash to owner approvals\\n    /// @dev Nested mapping structure optimizes gas for approval checks and prevents approval manipulation\\n    mapping(bytes32 => mapping(address => bool)) public approvals;\\n\\n    /// @notice Mapping of enabled module addresses\\n    /// @dev Modules can execute transactions via execTransactionFromModule but cannot modify module permissions\\n    mapping(address => bool) public modules;\\n\\n    /// @notice Emitted when a new transaction is proposed\\n    /// @param txHash Unique hash identifying the transaction\\n    /// @param proposer Address of the owner who proposed the transaction\\n    /// @param to Destination address for the transaction\\n    /// @param value Amount of QUAI to send\\n    /// @param data Calldata to execute at destination\\n    event TransactionProposed(\\n        bytes32 indexed txHash,\\n        address indexed proposer,\\n        address indexed to,\\n        uint256 value,\\n        bytes data\\n    );\\n\\n    /// @notice Emitted when an owner approves a transaction\\n    /// @param txHash Hash of the approved transaction\\n    /// @param approver Address of the owner who approved\\n    event TransactionApproved(\\n        bytes32 indexed txHash,\\n        address indexed approver\\n    );\\n\\n    /// @notice Emitted when a transaction is successfully executed\\n    /// @param txHash Hash of the executed transaction\\n    /// @param executor Address of the owner who triggered execution\\n    event TransactionExecuted(\\n        bytes32 indexed txHash,\\n        address indexed executor\\n    );\\n\\n    /// @notice Emitted when an owner revokes their approval\\n    /// @param txHash Hash of the transaction\\n    /// @param owner Address of the owner who revoked approval\\n    event ApprovalRevoked(\\n        bytes32 indexed txHash,\\n        address indexed owner\\n    );\\n\\n    /// @notice Emitted when a transaction is cancelled\\n    /// @param txHash Hash of the cancelled transaction\\n    /// @param canceller Address of the owner who cancelled\\n    event TransactionCancelled(\\n        bytes32 indexed txHash,\\n        address indexed canceller\\n    );\\n\\n    /// @notice Emitted when a new owner is added to the wallet\\n    /// @param owner Address of the new owner\\n    event OwnerAdded(address indexed owner);\\n\\n    /// @notice Emitted when an owner is removed from the wallet\\n    /// @param owner Address of the removed owner\\n    event OwnerRemoved(address indexed owner);\\n\\n    /// @notice Emitted when the approval threshold is changed\\n    /// @param threshold New threshold value\\n    event ThresholdChanged(uint256 threshold);\\n\\n    /// @notice Emitted when a module is enabled\\n    /// @param module Address of the enabled module\\n    event ModuleEnabled(address indexed module);\\n\\n    /// @notice Emitted when a module is disabled\\n    /// @param module Address of the disabled module\\n    event ModuleDisabled(address indexed module);\\n\\n    /// @notice Emitted when the wallet receives QUAI\\n    /// @param sender Address that sent the QUAI\\n    /// @param amount Amount of QUAI received\\n    event Received(address indexed sender, uint256 amount);\\n\\n    /// @notice Restricts function access to wallet owners only\\n    modifier onlyOwner() {\\n        if (!isOwner[msg.sender]) revert NotAnOwner();\\n        _;\\n    }\\n\\n    /// @notice Restricts function access to the wallet itself (for multisig-approved actions)\\n    modifier onlySelf() {\\n        if (msg.sender != address(this)) revert OnlySelf();\\n        _;\\n    }\\n\\n    /// @notice Restricts function access to enabled modules only\\n    modifier onlyModule() {\\n        if (!modules[msg.sender]) revert NotAnAuthorizedModule();\\n        _;\\n    }\\n\\n    /// @notice Ensures the specified transaction exists\\n    /// @param txHash Transaction hash to check\\n    modifier txExists(bytes32 txHash) {\\n        if (transactions[txHash].to == address(0)) revert TransactionDoesNotExist();\\n        _;\\n    }\\n\\n    /// @notice Ensures the specified transaction has not been executed\\n    /// @param txHash Transaction hash to check\\n    modifier notExecuted(bytes32 txHash) {\\n        if (transactions[txHash].executed) revert TransactionAlreadyExecuted();\\n        _;\\n    }\\n\\n    /// @notice Ensures the specified transaction has not been cancelled\\n    /// @param txHash Transaction hash to check\\n    modifier notCancelled(bytes32 txHash) {\\n        if (transactions[txHash].cancelled) revert TransactionAlreadyCancelled();\\n        _;\\n    }\\n\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\n    constructor() {\\n        _disableInitializers();\\n    }\\n\\n    /**\\n     * @notice Initialize the multisig wallet\\n     * @param _owners Array of owner addresses\\n     * @param _threshold Number of required approvals\\n     */\\n    function initialize(\\n        address[] memory _owners,\\n        uint256 _threshold\\n    ) external initializer {\\n        if (_owners.length == 0) revert OwnersRequired();\\n        if (_owners.length > MAX_OWNERS) revert TooManyOwners();\\n        if (_threshold == 0 || _threshold > _owners.length) revert InvalidThreshold();\\n\\n        __ReentrancyGuard_init();\\n\\n        // Validate and set owners\\n        for (uint256 i = 0; i < _owners.length; i++) {\\n            address owner = _owners[i];\\n\\n            if (owner == address(0)) revert InvalidOwnerAddress();\\n            if (isOwner[owner]) revert DuplicateOwner();\\n\\n            isOwner[owner] = true;\\n            owners.push(owner);\\n        }\\n\\n        threshold = _threshold;\\n        nonce = 0;\\n    }\\n\\n    /**\\n     * @notice Propose a new transaction\\n     * @param to Destination address\\n     * @param value Amount of Quai to send\\n     * @param data Transaction data\\n     * @return txHash The transaction hash\\n     */\\n    function proposeTransaction(\\n        address to,\\n        uint256 value,\\n        bytes memory data\\n    ) external onlyOwner returns (bytes32) {\\n        if (to == address(0)) revert InvalidDestinationAddress();\\n\\n        bytes32 txHash = getTransactionHash(to, value, data, nonce);\\n\\n        // Check if transaction already exists\\n        Transaction storage existingTx = transactions[txHash];\\n        bool isOverwritingCancelled = false;\\n\\n        // If transaction exists and is not cancelled, reject\\n        if (existingTx.to != address(0)) {\\n            if (!existingTx.cancelled) revert TransactionAlreadyExists();\\n            // If cancelled, we'll overwrite it below (treat as new proposal)\\n            isOverwritingCancelled = true;\\n        }\\n\\n        // If overwriting a cancelled transaction, clear all existing approvals\\n        // This is necessary because approveTransaction checks if an owner has already approved\\n        if (isOverwritingCancelled) {\\n            for (uint256 i = 0; i < owners.length; i++) {\\n                approvals[txHash][owners[i]] = false;\\n            }\\n        }\\n\\n        // Create or overwrite transaction (if it was cancelled)\\n        transactions[txHash] = Transaction({\\n            to: to,\\n            value: value,\\n            data: data,\\n            executed: false,\\n            cancelled: false,\\n            numApprovals: 0,\\n            timestamp: block.timestamp,\\n            proposer: msg.sender\\n        });\\n\\n        // Increment nonce on proposal to prevent hash collisions\\n        // This ensures each proposal gets a unique hash even if cancelled and re-proposed\\n        nonce++;\\n\\n        emit TransactionProposed(txHash, msg.sender, to, value, data);\\n\\n        return txHash;\\n    }\\n\\n    /**\\n     * @notice Approve a pending transaction\\n     * @param txHash Transaction hash to approve\\n     */\\n    function approveTransaction(bytes32 txHash)\\n        external\\n        onlyOwner\\n        txExists(txHash)\\n        notExecuted(txHash)\\n        notCancelled(txHash)\\n    {\\n        if (approvals[txHash][msg.sender]) revert AlreadyApproved();\\n\\n        approvals[txHash][msg.sender] = true;\\n        transactions[txHash].numApprovals++;\\n\\n        emit TransactionApproved(txHash, msg.sender);\\n    }\\n\\n    /**\\n     * @notice Approve and execute a transaction in one call if threshold is met\\n     * @dev Prevents frontrunning by combining approval and execution atomically\\n     * @param txHash Transaction hash to approve and potentially execute\\n     * @return executed Whether the transaction was executed\\n     */\\n    function approveAndExecute(bytes32 txHash)\\n        external\\n        onlyOwner\\n        txExists(txHash)\\n        notExecuted(txHash)\\n        notCancelled(txHash)\\n        nonReentrant\\n        returns (bool executed)\\n    {\\n        // First, approve if not already approved\\n        if (!approvals[txHash][msg.sender]) {\\n            approvals[txHash][msg.sender] = true;\\n            transactions[txHash].numApprovals++;\\n            emit TransactionApproved(txHash, msg.sender);\\n        }\\n\\n        // Check if threshold is met\\n        Transaction storage transaction = transactions[txHash];\\n        if (transaction.numApprovals >= threshold) {\\n            // Execute the transaction\\n            transaction.executed = true;\\n\\n            // Handle self-calls (owner management) differently\\n            if (transaction.to == address(this)) {\\n                bytes4 selector = bytes4(transaction.data);\\n\\n                if (selector == this.addOwner.selector) {\\n                    bytes memory dataSlice = new bytes(transaction.data.length - 4);\\n                    for (uint256 i = 4; i < transaction.data.length; i++) {\\n                        dataSlice[i - 4] = transaction.data[i];\\n                    }\\n                    address newOwner = abi.decode(dataSlice, (address));\\n                    _addOwner(newOwner);\\n                } else if (selector == this.removeOwner.selector) {\\n                    bytes memory dataSlice = new bytes(transaction.data.length - 4);\\n                    for (uint256 i = 4; i < transaction.data.length; i++) {\\n                        dataSlice[i - 4] = transaction.data[i];\\n                    }\\n                    address ownerToRemove = abi.decode(dataSlice, (address));\\n                    _removeOwner(ownerToRemove);\\n                } else if (selector == this.changeThreshold.selector) {\\n                    bytes memory dataSlice = new bytes(transaction.data.length - 4);\\n                    for (uint256 i = 4; i < transaction.data.length; i++) {\\n                        dataSlice[i - 4] = transaction.data[i];\\n                    }\\n                    uint256 newThreshold = abi.decode(dataSlice, (uint256));\\n                    _changeThreshold(newThreshold);\\n                } else {\\n                    (bool success, ) = transaction.to.call{value: transaction.value}(\\n                        transaction.data\\n                    );\\n                    if (!success) revert TransactionExecutionFailed();\\n                }\\n            } else {\\n                (bool success, ) = transaction.to.call{value: transaction.value}(\\n                    transaction.data\\n                );\\n                if (!success) revert TransactionExecutionFailed();\\n            }\\n\\n            emit TransactionExecuted(txHash, msg.sender);\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    /**\\n     * @notice Execute a transaction after threshold is met\\n     * @param txHash Transaction hash to execute\\n     */\\n    function executeTransaction(bytes32 txHash)\\n        external\\n        onlyOwner\\n        txExists(txHash)\\n        notExecuted(txHash)\\n        notCancelled(txHash)\\n        nonReentrant\\n    {\\n        Transaction storage transaction = transactions[txHash];\\n\\n        // Explicit check: cancelled transactions cannot be executed\\n        // (Defense-in-depth: modifier already checks this, but explicit for clarity)\\n        if (transaction.cancelled) revert TransactionHasBeenCancelled();\\n\\n        if (transaction.numApprovals < threshold) revert NotEnoughApprovals();\\n\\n        transaction.executed = true;\\n\\n        // Handle self-calls (owner management) differently to avoid reentrancy guard issues\\n        if (transaction.to == address(this)) {\\n            // For self-calls, decode and execute using internal functions\\n            // This avoids the reentrancy guard blocking external calls\\n            bytes4 selector = bytes4(transaction.data);\\n            \\n            if (selector == this.addOwner.selector) {\\n                // Decode addOwner(address)\\n                bytes memory dataSlice = new bytes(transaction.data.length - 4);\\n                for (uint256 i = 4; i < transaction.data.length; i++) {\\n                    dataSlice[i - 4] = transaction.data[i];\\n                }\\n                address newOwner = abi.decode(dataSlice, (address));\\n                _addOwner(newOwner);\\n            } else if (selector == this.removeOwner.selector) {\\n                // Decode removeOwner(address)\\n                bytes memory dataSlice = new bytes(transaction.data.length - 4);\\n                for (uint256 i = 4; i < transaction.data.length; i++) {\\n                    dataSlice[i - 4] = transaction.data[i];\\n                }\\n                address ownerToRemove = abi.decode(dataSlice, (address));\\n                _removeOwner(ownerToRemove);\\n            } else if (selector == this.changeThreshold.selector) {\\n                // Decode changeThreshold(uint256)\\n                bytes memory dataSlice = new bytes(transaction.data.length - 4);\\n                for (uint256 i = 4; i < transaction.data.length; i++) {\\n                    dataSlice[i - 4] = transaction.data[i];\\n                }\\n                uint256 newThreshold = abi.decode(dataSlice, (uint256));\\n                _changeThreshold(newThreshold);\\n            } else {\\n                // Unknown self-call function - try using call anyway\\n                (bool success, ) = transaction.to.call{value: transaction.value}(\\n                    transaction.data\\n                );\\n                if (!success) revert TransactionExecutionFailed();\\n            }\\n        } else {\\n            // External call - use standard call mechanism\\n            (bool success, ) = transaction.to.call{value: transaction.value}(\\n                transaction.data\\n            );\\n            if (!success) revert TransactionExecutionFailed();\\n        }\\n\\n        emit TransactionExecuted(txHash, msg.sender);\\n    }\\n\\n    /**\\n     * @notice Revoke approval for a pending transaction\\n     * @param txHash Transaction hash\\n     */\\n    function revokeApproval(bytes32 txHash)\\n        external\\n        onlyOwner\\n        txExists(txHash)\\n        notExecuted(txHash)\\n        notCancelled(txHash)\\n    {\\n        if (!approvals[txHash][msg.sender]) revert NotApproved();\\n\\n        approvals[txHash][msg.sender] = false;\\n        transactions[txHash].numApprovals--;\\n\\n        emit ApprovalRevoked(txHash, msg.sender);\\n    }\\n\\n    /**\\n     * @notice Cancel a pending transaction\\n     * @dev Can be cancelled by the proposer immediately, or by threshold approvals\\n     * @param txHash Transaction hash to cancel\\n     */\\n    function cancelTransaction(bytes32 txHash)\\n        external\\n        onlyOwner\\n        txExists(txHash)\\n        notExecuted(txHash)\\n        notCancelled(txHash)\\n    {\\n        Transaction storage transaction = transactions[txHash];\\n\\n        // Check if caller is the proposer\\n        bool isProposer = transaction.proposer == msg.sender;\\n\\n        // If not proposer, require threshold approvals\\n        if (!isProposer) {\\n            if (transaction.numApprovals < threshold) revert NotProposerAndNotEnoughApprovalsToCancel();\\n        }\\n\\n        // Mark as cancelled\\n        transaction.cancelled = true;\\n\\n        // Clear all approvals (clean up state)\\n        // Note: We don't need to iterate through all owners since approvals mapping\\n        // will just be ignored for cancelled transactions, but we reset numApprovals\\n        // for clarity and potential gas savings in future reads\\n        transaction.numApprovals = 0;\\n\\n        emit TransactionCancelled(txHash, msg.sender);\\n    }\\n\\n    /**\\n     * @notice Internal function to add a new owner\\n     * @param owner Address of new owner\\n     */\\n    function _addOwner(address owner) internal {\\n        if (owner == address(0)) revert InvalidOwnerAddress();\\n        if (isOwner[owner]) revert AlreadyAnOwner();\\n        if (owners.length >= MAX_OWNERS) revert MaxOwnersReached();\\n\\n        isOwner[owner] = true;\\n        owners.push(owner);\\n\\n        emit OwnerAdded(owner);\\n    }\\n\\n    /**\\n     * @notice Add a new owner (requires multisig approval)\\n     * @param owner Address of new owner\\n     */\\n    function addOwner(address owner) external onlySelf {\\n        _addOwner(owner);\\n    }\\n\\n    /**\\n     * @notice Internal function to remove an owner\\n     * @param owner Address of owner to remove\\n     */\\n    function _removeOwner(address owner) internal {\\n        if (!isOwner[owner]) revert NotAnOwner();\\n        if (owners.length - 1 < threshold) revert CannotRemoveOwnerWouldFallBelowThreshold();\\n\\n        isOwner[owner] = false;\\n\\n        // Remove from owners array\\n        for (uint256 i = 0; i < owners.length; i++) {\\n            if (owners[i] == owner) {\\n                owners[i] = owners[owners.length - 1];\\n                owners.pop();\\n                break;\\n            }\\n        }\\n\\n        emit OwnerRemoved(owner);\\n    }\\n\\n    /**\\n     * @notice Remove an owner (requires multisig approval)\\n     * @param owner Address of owner to remove\\n     */\\n    function removeOwner(address owner) external onlySelf {\\n        _removeOwner(owner);\\n    }\\n\\n    /**\\n     * @notice Internal function to change the approval threshold\\n     * @param _threshold New threshold value\\n     */\\n    function _changeThreshold(uint256 _threshold) internal {\\n        if (_threshold == 0 || _threshold > owners.length) revert InvalidThreshold();\\n\\n        threshold = _threshold;\\n\\n        emit ThresholdChanged(_threshold);\\n    }\\n\\n    /**\\n     * @notice Change the approval threshold (requires multisig approval)\\n     * @param _threshold New threshold value\\n     */\\n    function changeThreshold(uint256 _threshold) external onlySelf {\\n        _changeThreshold(_threshold);\\n    }\\n\\n    /**\\n     * @notice Enable a module\\n     * @param module Module address to enable\\n     */\\n    function enableModule(address module) external onlySelf {\\n        if (module == address(0)) revert InvalidModuleAddress();\\n        if (modules[module]) revert ModuleAlreadyEnabled();\\n\\n        modules[module] = true;\\n\\n        emit ModuleEnabled(module);\\n    }\\n\\n    /**\\n     * @notice Disable a module\\n     * @param module Module address to disable\\n     */\\n    function disableModule(address module) external onlySelf {\\n        if (!modules[module]) revert ModuleNotEnabled();\\n\\n        modules[module] = false;\\n\\n        emit ModuleDisabled(module);\\n    }\\n\\n    /**\\n     * @notice Execute transaction from authorized module\\n     * @dev Modules cannot call enableModule/disableModule (prevents privilege escalation)\\n     *      Owner management functions (addOwner, removeOwner, changeThreshold) are allowed\\n     *      for legitimate use cases like social recovery\\n     * @param to Destination address\\n     * @param value Amount to send\\n     * @param data Transaction data\\n     * @return success True if the transaction succeeded, false otherwise\\n     */\\n    function execTransactionFromModule(\\n        address to,\\n        uint256 value,\\n        bytes memory data\\n    ) external onlyModule nonReentrant returns (bool) {\\n        if (to == address(0)) revert InvalidDestinationAddress();\\n\\n        // Security: Prevent modules from modifying module permissions\\n        // This prevents a compromised module from enabling/disabling other modules\\n        // Owner management functions ARE allowed for legitimate recovery scenarios\\n        if (to == address(this) && data.length >= 4) {\\n            bytes4 selector = bytes4(data);\\n            if (selector == this.enableModule.selector || selector == this.disableModule.selector) {\\n                revert ModuleCannotModifyModulePermissions();\\n            }\\n        }\\n\\n        (bool success, ) = to.call{value: value}(data);\\n        return success;\\n    }\\n\\n    /**\\n     * @notice Get transaction hash\\n     * @param to Destination address\\n     * @param value Amount\\n     * @param data Transaction data\\n     * @param _nonce Nonce value\\n     * @return Unique bytes32 hash computed from wallet address, transaction parameters, nonce, and chain ID\\n     */\\n    function getTransactionHash(\\n        address to,\\n        uint256 value,\\n        bytes memory data,\\n        uint256 _nonce\\n    ) public view returns (bytes32) {\\n        return keccak256(\\n            abi.encodePacked(\\n                address(this),\\n                to,\\n                value,\\n                data,\\n                _nonce,\\n                block.chainid\\n            )\\n        );\\n    }\\n\\n    /**\\n     * @notice Get all owners\\n     * @return Array of owner addresses\\n     */\\n    function getOwners() external view returns (address[] memory) {\\n        return owners;\\n    }\\n\\n    /**\\n     * @notice Get owner count\\n     * @return Number of owners\\n     */\\n    function getOwnerCount() external view returns (uint256) {\\n        return owners.length;\\n    }\\n\\n    /**\\n     * @notice Get transaction details\\n     * @param txHash Transaction hash\\n     * @return Transaction struct\\n     */\\n    function getTransaction(bytes32 txHash)\\n        external\\n        view\\n        returns (Transaction memory)\\n    {\\n        return transactions[txHash];\\n    }\\n\\n    /**\\n     * @notice Check if address has approved transaction\\n     * @param txHash Transaction hash\\n     * @param owner Owner address\\n     * @return True if approved\\n     */\\n    function hasApproved(bytes32 txHash, address owner)\\n        external\\n        view\\n        returns (bool)\\n    {\\n        return approvals[txHash][owner];\\n    }\\n\\n    /**\\n     * @notice Receive function to accept Quai\\n     */\\n    receive() external payable {\\n        emit Received(msg.sender, msg.value);\\n    }\\n\\n    /**\\n     * @notice Fallback function\\n     */\\n    fallback() external payable {\\n        emit Received(msg.sender, msg.value);\\n    }\\n}\\n\",\"keccak256\":\"0xd793edd4525ca34439ef17a481c0967a67a853428f563e9ed0c5d0ea67c329c2\",\"license\":\"MIT\"},\"contracts/modules/DailyLimitModule.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport \\\"../MultisigWallet.sol\\\";\\n\\n/**\\n * @title DailyLimitModule\\n * @dev Module for setting daily spending limits on multisig wallets\\n * @notice Allows automatic execution of transactions below the daily limit\\n */\\ncontract DailyLimitModule {\\n    /// @notice Structure representing a wallet's daily spending limit\\n    /// @dev Reset automatically after 24 hours\\n    struct DailyLimit {\\n        /// @notice Maximum amount that can be spent per day (in wei)\\n        uint256 limit;\\n        /// @notice Amount already spent in current period (in wei)\\n        uint256 spent;\\n        /// @notice Timestamp of last limit reset\\n        uint256 lastReset;\\n    }\\n\\n    // Custom errors (gas efficient)\\n    error MustBeCalledByWallet();\\n    error ModuleNotEnabled();\\n    error NotAnOwner();\\n    error InvalidDestination();\\n    error DailyLimitNotSet();\\n    error ExceedsDailyLimit();\\n    error TransactionFailed();\\n\\n    /// @notice Mapping from wallet address to its daily limit configuration\\n    /// @dev Each wallet has independent limit tracking; automatically resets after 24 hours from lastReset\\n    mapping(address => DailyLimit) public dailyLimits;\\n\\n    /// @notice Emitted when a daily limit is set or updated\\n    /// @param wallet Address of the multisig wallet\\n    /// @param limit New daily limit in wei\\n    event DailyLimitSet(address indexed wallet, uint256 limit);\\n\\n    /// @notice Emitted when a transaction is executed within the daily limit\\n    /// @param wallet Address of the multisig wallet\\n    /// @param to Destination address\\n    /// @param value Amount sent in wei\\n    /// @param remainingLimit Remaining daily limit after transaction\\n    event TransactionExecuted(\\n        address indexed wallet,\\n        address indexed to,\\n        uint256 value,\\n        uint256 remainingLimit\\n    );\\n\\n    /// @notice Emitted when the daily limit is reset\\n    /// @param wallet Address of the multisig wallet\\n    event DailyLimitReset(address indexed wallet);\\n\\n    /**\\n     * @notice Set daily spending limit\\n     * @param wallet Multisig wallet address\\n     * @param limit Daily limit in wei\\n     * @dev SECURITY: Must be called through multisig transaction (msg.sender == wallet)\\n     *      This prevents a single owner from unilaterally setting limits\\n     */\\n    function setDailyLimit(address wallet, uint256 limit) external {\\n        // SECURITY FIX (H-2): Require multisig approval by checking msg.sender == wallet\\n        // Previously only required isOwner, allowing single owner bypass\\n        if (msg.sender != wallet) revert MustBeCalledByWallet();\\n        MultisigWallet multisig = MultisigWallet(payable(wallet));\\n        if (!multisig.modules(address(this))) revert ModuleNotEnabled();\\n\\n        dailyLimits[wallet].limit = limit;\\n\\n        // Initialize lastReset if not set\\n        if (dailyLimits[wallet].lastReset == 0) {\\n            dailyLimits[wallet].lastReset = block.timestamp;\\n        }\\n\\n        emit DailyLimitSet(wallet, limit);\\n    }\\n\\n    /**\\n     * @notice Execute transaction if below daily limit\\n     * @param wallet Multisig wallet address\\n     * @param to Destination address\\n     * @param value Amount to send\\n     */\\n    function executeBelowLimit(\\n        address wallet,\\n        address to,\\n        uint256 value\\n    ) external {\\n        MultisigWallet multisig = MultisigWallet(payable(wallet));\\n        if (!multisig.isOwner(msg.sender)) revert NotAnOwner();\\n        if (!multisig.modules(address(this))) revert ModuleNotEnabled();\\n        if (to == address(0)) revert InvalidDestination();\\n\\n        DailyLimit storage limit = dailyLimits[wallet];\\n        if (limit.limit == 0) revert DailyLimitNotSet();\\n\\n        // Reset if 24 hours have passed\\n        if (block.timestamp >= limit.lastReset + 1 days) {\\n            limit.spent = 0;\\n            limit.lastReset = block.timestamp;\\n            emit DailyLimitReset(wallet);\\n        }\\n\\n        // Check if transaction is within limit\\n        if (limit.spent + value > limit.limit) revert ExceedsDailyLimit();\\n\\n        // Update spent amount\\n        limit.spent += value;\\n\\n        // Execute transaction through wallet\\n        bool success = multisig.execTransactionFromModule(to, value, \\\"\\\");\\n        if (!success) revert TransactionFailed();\\n\\n        emit TransactionExecuted(\\n            wallet,\\n            to,\\n            value,\\n            limit.limit - limit.spent\\n        );\\n    }\\n\\n    /**\\n     * @notice Manually reset daily limit\\n     * @param wallet Multisig wallet address\\n     * @dev SECURITY: Must be called through multisig transaction (msg.sender == wallet)\\n     *      This prevents a single owner from unilaterally resetting the limit\\n     */\\n    function resetDailyLimit(address wallet) external {\\n        // SECURITY FIX (H-2): Require multisig approval by checking msg.sender == wallet\\n        if (msg.sender != wallet) revert MustBeCalledByWallet();\\n        MultisigWallet multisig = MultisigWallet(payable(wallet));\\n        if (!multisig.modules(address(this))) revert ModuleNotEnabled();\\n\\n        DailyLimit storage limit = dailyLimits[wallet];\\n        limit.spent = 0;\\n        limit.lastReset = block.timestamp;\\n\\n        emit DailyLimitReset(wallet);\\n    }\\n\\n    /**\\n     * @notice Get remaining daily limit\\n     * @param wallet Multisig wallet address\\n     * @return Remaining limit in wei\\n     */\\n    function getRemainingLimit(address wallet) external view returns (uint256) {\\n        DailyLimit memory limit = dailyLimits[wallet];\\n\\n        if (limit.limit == 0) {\\n            return 0;\\n        }\\n\\n        // Check if limit should be reset\\n        if (block.timestamp >= limit.lastReset + 1 days) {\\n            return limit.limit;\\n        }\\n\\n        if (limit.spent >= limit.limit) {\\n            return 0;\\n        }\\n\\n        return limit.limit - limit.spent;\\n    }\\n\\n    /**\\n     * @notice Get time until limit resets\\n     * @param wallet Multisig wallet address\\n     * @return Seconds until reset\\n     */\\n    function getTimeUntilReset(address wallet) external view returns (uint256) {\\n        DailyLimit memory limit = dailyLimits[wallet];\\n\\n        if (limit.lastReset == 0) {\\n            return 0;\\n        }\\n\\n        uint256 resetTime = limit.lastReset + 1 days;\\n\\n        if (block.timestamp >= resetTime) {\\n            return 0;\\n        }\\n\\n        return resetTime - block.timestamp;\\n    }\\n\\n    /**\\n     * @notice Get daily limit configuration\\n     * @param wallet Multisig wallet address\\n     * @return Daily limit details\\n     */\\n    function getDailyLimit(address wallet)\\n        external\\n        view\\n        returns (DailyLimit memory)\\n    {\\n        return dailyLimits[wallet];\\n    }\\n}\\n\",\"keccak256\":\"0xf44b395befc3ff779d345ad855703b3196528dcb6b092a4a7c4e06bbe57fb28b\",\"license\":\"MIT\"}},\"version\":1}"