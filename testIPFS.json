{"compiler":{"version":"0.8.22+commit.4fc1097e"},"language":"Solidity","output":{"abi":[{"inputs":[],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[],"name":"AlreadyAnOwner","type":"error"},{"inputs":[],"name":"AlreadyApproved","type":"error"},{"inputs":[],"name":"CannotRemoveOwnerWouldFallBelowThreshold","type":"error"},{"inputs":[],"name":"DuplicateOwner","type":"error"},{"inputs":[],"name":"InvalidDestinationAddress","type":"error"},{"inputs":[],"name":"InvalidInitialization","type":"error"},{"inputs":[],"name":"InvalidModuleAddress","type":"error"},{"inputs":[],"name":"InvalidOwnerAddress","type":"error"},{"inputs":[],"name":"InvalidThreshold","type":"error"},{"inputs":[],"name":"MaxOwnersReached","type":"error"},{"inputs":[],"name":"ModuleAlreadyEnabled","type":"error"},{"inputs":[],"name":"ModuleCannotModifyModulePermissions","type":"error"},{"inputs":[],"name":"ModuleNotEnabled","type":"error"},{"inputs":[],"name":"NotAnAuthorizedModule","type":"error"},{"inputs":[],"name":"NotAnOwner","type":"error"},{"inputs":[],"name":"NotApproved","type":"error"},{"inputs":[],"name":"NotEnoughApprovals","type":"error"},{"inputs":[],"name":"NotInitializing","type":"error"},{"inputs":[],"name":"NotProposerAndNotEnoughApprovalsToCancel","type":"error"},{"inputs":[],"name":"OnlySelf","type":"error"},{"inputs":[],"name":"OwnersRequired","type":"error"},{"inputs":[],"name":"ReentrancyGuardReentrantCall","type":"error"},{"inputs":[],"name":"TooManyOwners","type":"error"},{"inputs":[],"name":"TransactionAlreadyCancelled","type":"error"},{"inputs":[],"name":"TransactionAlreadyExecuted","type":"error"},{"inputs":[],"name":"TransactionAlreadyExists","type":"error"},{"inputs":[],"name":"TransactionDoesNotExist","type":"error"},{"inputs":[],"name":"TransactionExecutionFailed","type":"error"},{"inputs":[],"name":"TransactionHasBeenCancelled","type":"error"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"txHash","type":"bytes32"},{"indexed":true,"internalType":"address","name":"owner","type":"address"}],"name":"ApprovalRevoked","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint64","name":"version","type":"uint64"}],"name":"Initialized","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"module","type":"address"}],"name":"ModuleDisabled","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"module","type":"address"}],"name":"ModuleEnabled","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"}],"name":"OwnerAdded","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"}],"name":"OwnerRemoved","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"Received","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"threshold","type":"uint256"}],"name":"ThresholdChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"txHash","type":"bytes32"},{"indexed":true,"internalType":"address","name":"approver","type":"address"}],"name":"TransactionApproved","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"txHash","type":"bytes32"},{"indexed":true,"internalType":"address","name":"canceller","type":"address"}],"name":"TransactionCancelled","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"txHash","type":"bytes32"},{"indexed":true,"internalType":"address","name":"executor","type":"address"}],"name":"TransactionExecuted","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"txHash","type":"bytes32"},{"indexed":true,"internalType":"address","name":"proposer","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"},{"indexed":false,"internalType":"bytes","name":"data","type":"bytes"}],"name":"TransactionProposed","type":"event"},{"stateMutability":"payable","type":"fallback"},{"inputs":[],"name":"MAX_OWNERS","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"addOwner","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"","type":"bytes32"},{"internalType":"address","name":"","type":"address"}],"name":"approvals","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"txHash","type":"bytes32"}],"name":"approveAndExecute","outputs":[{"internalType":"bool","name":"executed","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"txHash","type":"bytes32"}],"name":"approveTransaction","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"txHash","type":"bytes32"}],"name":"cancelTransaction","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_threshold","type":"uint256"}],"name":"changeThreshold","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"module","type":"address"}],"name":"disableModule","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"module","type":"address"}],"name":"enableModule","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"},{"internalType":"bytes","name":"data","type":"bytes"}],"name":"execTransactionFromModule","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"txHash","type":"bytes32"}],"name":"executeTransaction","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"getOwnerCount","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getOwners","outputs":[{"internalType":"address[]","name":"","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"txHash","type":"bytes32"}],"name":"getTransaction","outputs":[{"components":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"},{"internalType":"bytes","name":"data","type":"bytes"},{"internalType":"bool","name":"executed","type":"bool"},{"internalType":"bool","name":"cancelled","type":"bool"},{"internalType":"uint256","name":"numApprovals","type":"uint256"},{"internalType":"uint256","name":"timestamp","type":"uint256"},{"internalType":"address","name":"proposer","type":"address"}],"internalType":"struct MultisigWallet.Transaction","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"},{"internalType":"bytes","name":"data","type":"bytes"},{"internalType":"uint256","name":"_nonce","type":"uint256"}],"name":"getTransactionHash","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"txHash","type":"bytes32"},{"internalType":"address","name":"owner","type":"address"}],"name":"hasApproved","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address[]","name":"_owners","type":"address[]"},{"internalType":"uint256","name":"_threshold","type":"uint256"}],"name":"initialize","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"isOwner","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"modules","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"nonce","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"owners","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"},{"internalType":"bytes","name":"data","type":"bytes"}],"name":"proposeTransaction","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"removeOwner","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"txHash","type":"bytes32"}],"name":"revokeApproval","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"threshold","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"name":"transactions","outputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"},{"internalType":"bytes","name":"data","type":"bytes"},{"internalType":"bool","name":"executed","type":"bool"},{"internalType":"bool","name":"cancelled","type":"bool"},{"internalType":"uint256","name":"numApprovals","type":"uint256"},{"internalType":"uint256","name":"timestamp","type":"uint256"},{"internalType":"address","name":"proposer","type":"address"}],"stateMutability":"view","type":"function"},{"stateMutability":"payable","type":"receive"}],"devdoc":{"details":"Core multisig wallet implementation with upgradeable proxy pattern","errors":{"InvalidInitialization()":[{"details":"The contract is already initialized."}],"NotInitializing()":[{"details":"The contract is not initializing."}],"ReentrancyGuardReentrantCall()":[{"details":"Unauthorized reentrant call."}]},"events":{"ApprovalRevoked(bytes32,address)":{"params":{"owner":"Address of the owner who revoked approval","txHash":"Hash of the transaction"}},"Initialized(uint64)":{"details":"Triggered when the contract has been initialized or reinitialized."},"ModuleDisabled(address)":{"params":{"module":"Address of the disabled module"}},"ModuleEnabled(address)":{"params":{"module":"Address of the enabled module"}},"OwnerAdded(address)":{"params":{"owner":"Address of the new owner"}},"OwnerRemoved(address)":{"params":{"owner":"Address of the removed owner"}},"Received(address,uint256)":{"params":{"amount":"Amount of QUAI received","sender":"Address that sent the QUAI"}},"ThresholdChanged(uint256)":{"params":{"threshold":"New threshold value"}},"TransactionApproved(bytes32,address)":{"params":{"approver":"Address of the owner who approved","txHash":"Hash of the approved transaction"}},"TransactionCancelled(bytes32,address)":{"params":{"canceller":"Address of the owner who cancelled","txHash":"Hash of the cancelled transaction"}},"TransactionExecuted(bytes32,address)":{"params":{"executor":"Address of the owner who triggered execution","txHash":"Hash of the executed transaction"}},"TransactionProposed(bytes32,address,address,uint256,bytes)":{"params":{"data":"Calldata to execute at destination","proposer":"Address of the owner who proposed the transaction","to":"Destination address for the transaction","txHash":"Unique hash identifying the transaction","value":"Amount of QUAI to send"}}},"kind":"dev","methods":{"addOwner(address)":{"params":{"owner":"Address of new owner"}},"approveAndExecute(bytes32)":{"details":"Prevents frontrunning by combining approval and execution atomically","params":{"txHash":"Transaction hash to approve and potentially execute"},"returns":{"executed":"Whether the transaction was executed"}},"approveTransaction(bytes32)":{"params":{"txHash":"Transaction hash to approve"}},"cancelTransaction(bytes32)":{"details":"Can be cancelled by the proposer immediately, or by threshold approvals","params":{"txHash":"Transaction hash to cancel"}},"changeThreshold(uint256)":{"params":{"_threshold":"New threshold value"}},"constructor":{"custom:oz-upgrades-unsafe-allow":"constructor"},"disableModule(address)":{"params":{"module":"Module address to disable"}},"enableModule(address)":{"params":{"module":"Module address to enable"}},"execTransactionFromModule(address,uint256,bytes)":{"details":"Modules cannot call enableModule/disableModule (prevents privilege escalation)      Owner management functions (addOwner, removeOwner, changeThreshold) are allowed      for legitimate use cases like social recovery","params":{"data":"Transaction data","to":"Destination address","value":"Amount to send"},"returns":{"_0":"success True if the transaction succeeded, false otherwise"}},"executeTransaction(bytes32)":{"params":{"txHash":"Transaction hash to execute"}},"getOwnerCount()":{"returns":{"_0":"Number of owners"}},"getOwners()":{"returns":{"_0":"Array of owner addresses"}},"getTransaction(bytes32)":{"params":{"txHash":"Transaction hash"},"returns":{"_0":"Transaction struct"}},"getTransactionHash(address,uint256,bytes,uint256)":{"params":{"_nonce":"Nonce value","data":"Transaction data","to":"Destination address","value":"Amount"},"returns":{"_0":"Unique bytes32 hash computed from wallet address, transaction parameters, nonce, and chain ID"}},"hasApproved(bytes32,address)":{"params":{"owner":"Owner address","txHash":"Transaction hash"},"returns":{"_0":"True if approved"}},"initialize(address[],uint256)":{"params":{"_owners":"Array of owner addresses","_threshold":"Number of required approvals"}},"proposeTransaction(address,uint256,bytes)":{"params":{"data":"Transaction data","to":"Destination address","value":"Amount of Quai to send"},"returns":{"_0":"txHash The transaction hash"}},"removeOwner(address)":{"params":{"owner":"Address of owner to remove"}},"revokeApproval(bytes32)":{"params":{"txHash":"Transaction hash"}}},"stateVariables":{"approvals":{"details":"Nested mapping structure optimizes gas for approval checks and prevents approval manipulation"},"isOwner":{"details":"O(1) lookup for owner verification, more gas-efficient than iterating through owners array"},"modules":{"details":"Modules can execute transactions via execTransactionFromModule but cannot modify module permissions"},"nonce":{"details":"Incremented on each proposal to ensure unique transaction hashes, prevents replay attacks"},"owners":{"details":"Used for iteration when needed (e.g., clearing approvals), kept in sync with isOwner mapping"},"threshold":{"details":"Must satisfy: 1 <= threshold <= owners.length"},"transactions":{"details":"Uses bytes32 key instead of array for O(1) lookup and to support non-sequential proposals"}},"title":"MultisigWallet","version":1},"userdoc":{"events":{"ApprovalRevoked(bytes32,address)":{"notice":"Emitted when an owner revokes their approval"},"ModuleDisabled(address)":{"notice":"Emitted when a module is disabled"},"ModuleEnabled(address)":{"notice":"Emitted when a module is enabled"},"OwnerAdded(address)":{"notice":"Emitted when a new owner is added to the wallet"},"OwnerRemoved(address)":{"notice":"Emitted when an owner is removed from the wallet"},"Received(address,uint256)":{"notice":"Emitted when the wallet receives QUAI"},"ThresholdChanged(uint256)":{"notice":"Emitted when the approval threshold is changed"},"TransactionApproved(bytes32,address)":{"notice":"Emitted when an owner approves a transaction"},"TransactionCancelled(bytes32,address)":{"notice":"Emitted when a transaction is cancelled"},"TransactionExecuted(bytes32,address)":{"notice":"Emitted when a transaction is successfully executed"},"TransactionProposed(bytes32,address,address,uint256,bytes)":{"notice":"Emitted when a new transaction is proposed"}},"kind":"user","methods":{"MAX_OWNERS()":{"notice":"Maximum number of owners allowed (prevents DoS from gas-intensive loops)"},"addOwner(address)":{"notice":"Add a new owner (requires multisig approval)"},"approvals(bytes32,address)":{"notice":"Mapping of transaction hash to owner approvals"},"approveAndExecute(bytes32)":{"notice":"Approve and execute a transaction in one call if threshold is met"},"approveTransaction(bytes32)":{"notice":"Approve a pending transaction"},"cancelTransaction(bytes32)":{"notice":"Cancel a pending transaction"},"changeThreshold(uint256)":{"notice":"Change the approval threshold (requires multisig approval)"},"disableModule(address)":{"notice":"Disable a module"},"enableModule(address)":{"notice":"Enable a module"},"execTransactionFromModule(address,uint256,bytes)":{"notice":"Execute transaction from authorized module"},"executeTransaction(bytes32)":{"notice":"Execute a transaction after threshold is met"},"getOwnerCount()":{"notice":"Get owner count"},"getOwners()":{"notice":"Get all owners"},"getTransaction(bytes32)":{"notice":"Get transaction details"},"getTransactionHash(address,uint256,bytes,uint256)":{"notice":"Get transaction hash"},"hasApproved(bytes32,address)":{"notice":"Check if address has approved transaction"},"initialize(address[],uint256)":{"notice":"Initialize the multisig wallet"},"isOwner(address)":{"notice":"Mapping of address to owner status"},"modules(address)":{"notice":"Mapping of enabled module addresses"},"nonce()":{"notice":"Transaction nonce used for hash generation"},"owners(uint256)":{"notice":"Array of all owner addresses"},"proposeTransaction(address,uint256,bytes)":{"notice":"Propose a new transaction"},"removeOwner(address)":{"notice":"Remove an owner (requires multisig approval)"},"revokeApproval(bytes32)":{"notice":"Revoke approval for a pending transaction"},"threshold()":{"notice":"Number of approvals required to execute a transaction"},"transactions(bytes32)":{"notice":"Mapping of transaction hash to transaction data"}},"notice":"This is the implementation contract used by all proxy instances","version":1}},"settings":{"compilationTarget":{"contracts/MultisigWallet.sol":"MultisigWallet"},"evmVersion":"london","libraries":{},"metadata":{"bytecodeHash":"ipfs","useLiteralContent":true},"optimizer":{"enabled":true,"runs":1000},"remappings":[]},"sources":{"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n     *\n     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n     */\n    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n        return INITIALIZABLE_STORAGE;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        bytes32 slot = _initializableStorageSlot();\n        assembly {\n            $.slot := slot\n        }\n    }\n}\n","keccak256":"0xdb4d24ee2c087c391d587cd17adfe5b3f9d93b3110b1388c2ab6c7c0ad1dcd05","license":"MIT"},"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.ReentrancyGuard\n    struct ReentrancyGuardStorage {\n        uint256 _status;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ReentrancyGuard\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ReentrancyGuardStorageLocation = 0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\n\n    function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\n        assembly {\n            $.slot := ReentrancyGuardStorageLocation\n        }\n    }\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if ($._status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        $._status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        $._status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        return $._status == ENTERED;\n    }\n}\n","keccak256":"0x361126a17677994081cd9cb69c3f50cffff6e920d25cb7e428acdb1ae41d1866","license":"MIT"},"contracts/MultisigWallet.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\n\n/**\n * @title MultisigWallet\n * @dev Core multisig wallet implementation with upgradeable proxy pattern\n * @notice This is the implementation contract used by all proxy instances\n */\ncontract MultisigWallet is Initializable, ReentrancyGuardUpgradeable {\n    // Custom errors (gas efficient)\n    error NotAnOwner();\n    error OnlySelf();\n    error NotAnAuthorizedModule();\n    error TransactionDoesNotExist();\n    error TransactionAlreadyExecuted();\n    error TransactionAlreadyCancelled();\n    error OwnersRequired();\n    error TooManyOwners();\n    error InvalidThreshold();\n    error InvalidOwnerAddress();\n    error DuplicateOwner();\n    error InvalidDestinationAddress();\n    error TransactionAlreadyExists();\n    error AlreadyApproved();\n    error TransactionExecutionFailed();\n    error TransactionHasBeenCancelled();\n    error NotEnoughApprovals();\n    error NotApproved();\n    error NotProposerAndNotEnoughApprovalsToCancel();\n    error AlreadyAnOwner();\n    error MaxOwnersReached();\n    error CannotRemoveOwnerWouldFallBelowThreshold();\n    error InvalidModuleAddress();\n    error ModuleAlreadyEnabled();\n    error ModuleNotEnabled();\n    error ModuleCannotModifyModulePermissions();\n\n    /// @notice Maximum number of owners allowed (prevents DoS from gas-intensive loops)\n    uint256 public constant MAX_OWNERS = 50;\n\n    /// @notice Structure representing a multisig transaction\n    /// @dev Stores all transaction details including approval state\n    struct Transaction {\n        /// @notice Destination address for the transaction\n        address to;\n        /// @notice Amount of QUAI to send\n        uint256 value;\n        /// @notice Calldata to execute at destination\n        bytes data;\n        /// @notice Whether the transaction has been executed\n        bool executed;\n        /// @notice Whether the transaction has been cancelled\n        bool cancelled;\n        /// @notice Current number of owner approvals\n        uint256 numApprovals;\n        /// @notice Block timestamp when transaction was proposed\n        uint256 timestamp;\n        /// @notice Address of the owner who proposed the transaction\n        address proposer;\n    }\n\n    /// @notice Mapping of address to owner status\n    /// @dev O(1) lookup for owner verification, more gas-efficient than iterating through owners array\n    mapping(address => bool) public isOwner;\n\n    /// @notice Array of all owner addresses\n    /// @dev Used for iteration when needed (e.g., clearing approvals), kept in sync with isOwner mapping\n    address[] public owners;\n\n    /// @notice Number of approvals required to execute a transaction\n    /// @dev Must satisfy: 1 <= threshold <= owners.length\n    uint256 public threshold;\n\n    /// @notice Transaction nonce used for hash generation\n    /// @dev Incremented on each proposal to ensure unique transaction hashes, prevents replay attacks\n    uint256 public nonce;\n\n    /// @notice Mapping of transaction hash to transaction data\n    /// @dev Uses bytes32 key instead of array for O(1) lookup and to support non-sequential proposals\n    mapping(bytes32 => Transaction) public transactions;\n\n    /// @notice Mapping of transaction hash to owner approvals\n    /// @dev Nested mapping structure optimizes gas for approval checks and prevents approval manipulation\n    mapping(bytes32 => mapping(address => bool)) public approvals;\n\n    /// @notice Mapping of enabled module addresses\n    /// @dev Modules can execute transactions via execTransactionFromModule but cannot modify module permissions\n    mapping(address => bool) public modules;\n\n    /// @notice Emitted when a new transaction is proposed\n    /// @param txHash Unique hash identifying the transaction\n    /// @param proposer Address of the owner who proposed the transaction\n    /// @param to Destination address for the transaction\n    /// @param value Amount of QUAI to send\n    /// @param data Calldata to execute at destination\n    event TransactionProposed(\n        bytes32 indexed txHash,\n        address indexed proposer,\n        address indexed to,\n        uint256 value,\n        bytes data\n    );\n\n    /// @notice Emitted when an owner approves a transaction\n    /// @param txHash Hash of the approved transaction\n    /// @param approver Address of the owner who approved\n    event TransactionApproved(\n        bytes32 indexed txHash,\n        address indexed approver\n    );\n\n    /// @notice Emitted when a transaction is successfully executed\n    /// @param txHash Hash of the executed transaction\n    /// @param executor Address of the owner who triggered execution\n    event TransactionExecuted(\n        bytes32 indexed txHash,\n        address indexed executor\n    );\n\n    /// @notice Emitted when an owner revokes their approval\n    /// @param txHash Hash of the transaction\n    /// @param owner Address of the owner who revoked approval\n    event ApprovalRevoked(\n        bytes32 indexed txHash,\n        address indexed owner\n    );\n\n    /// @notice Emitted when a transaction is cancelled\n    /// @param txHash Hash of the cancelled transaction\n    /// @param canceller Address of the owner who cancelled\n    event TransactionCancelled(\n        bytes32 indexed txHash,\n        address indexed canceller\n    );\n\n    /// @notice Emitted when a new owner is added to the wallet\n    /// @param owner Address of the new owner\n    event OwnerAdded(address indexed owner);\n\n    /// @notice Emitted when an owner is removed from the wallet\n    /// @param owner Address of the removed owner\n    event OwnerRemoved(address indexed owner);\n\n    /// @notice Emitted when the approval threshold is changed\n    /// @param threshold New threshold value\n    event ThresholdChanged(uint256 threshold);\n\n    /// @notice Emitted when a module is enabled\n    /// @param module Address of the enabled module\n    event ModuleEnabled(address indexed module);\n\n    /// @notice Emitted when a module is disabled\n    /// @param module Address of the disabled module\n    event ModuleDisabled(address indexed module);\n\n    /// @notice Emitted when the wallet receives QUAI\n    /// @param sender Address that sent the QUAI\n    /// @param amount Amount of QUAI received\n    event Received(address indexed sender, uint256 amount);\n\n    /// @notice Restricts function access to wallet owners only\n    modifier onlyOwner() {\n        if (!isOwner[msg.sender]) revert NotAnOwner();\n        _;\n    }\n\n    /// @notice Restricts function access to the wallet itself (for multisig-approved actions)\n    modifier onlySelf() {\n        if (msg.sender != address(this)) revert OnlySelf();\n        _;\n    }\n\n    /// @notice Restricts function access to enabled modules only\n    modifier onlyModule() {\n        if (!modules[msg.sender]) revert NotAnAuthorizedModule();\n        _;\n    }\n\n    /// @notice Ensures the specified transaction exists\n    /// @param txHash Transaction hash to check\n    modifier txExists(bytes32 txHash) {\n        if (transactions[txHash].to == address(0)) revert TransactionDoesNotExist();\n        _;\n    }\n\n    /// @notice Ensures the specified transaction has not been executed\n    /// @param txHash Transaction hash to check\n    modifier notExecuted(bytes32 txHash) {\n        if (transactions[txHash].executed) revert TransactionAlreadyExecuted();\n        _;\n    }\n\n    /// @notice Ensures the specified transaction has not been cancelled\n    /// @param txHash Transaction hash to check\n    modifier notCancelled(bytes32 txHash) {\n        if (transactions[txHash].cancelled) revert TransactionAlreadyCancelled();\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Initialize the multisig wallet\n     * @param _owners Array of owner addresses\n     * @param _threshold Number of required approvals\n     */\n    function initialize(\n        address[] memory _owners,\n        uint256 _threshold\n    ) external initializer {\n        if (_owners.length == 0) revert OwnersRequired();\n        if (_owners.length > MAX_OWNERS) revert TooManyOwners();\n        if (_threshold == 0 || _threshold > _owners.length) revert InvalidThreshold();\n\n        __ReentrancyGuard_init();\n\n        // Validate and set owners\n        for (uint256 i = 0; i < _owners.length; i++) {\n            address owner = _owners[i];\n\n            if (owner == address(0)) revert InvalidOwnerAddress();\n            if (isOwner[owner]) revert DuplicateOwner();\n\n            isOwner[owner] = true;\n            owners.push(owner);\n        }\n\n        threshold = _threshold;\n        nonce = 0;\n    }\n\n    /**\n     * @notice Propose a new transaction\n     * @param to Destination address\n     * @param value Amount of Quai to send\n     * @param data Transaction data\n     * @return txHash The transaction hash\n     */\n    function proposeTransaction(\n        address to,\n        uint256 value,\n        bytes memory data\n    ) external onlyOwner returns (bytes32) {\n        if (to == address(0)) revert InvalidDestinationAddress();\n\n        bytes32 txHash = getTransactionHash(to, value, data, nonce);\n\n        // Check if transaction already exists\n        Transaction storage existingTx = transactions[txHash];\n        bool isOverwritingCancelled = false;\n\n        // If transaction exists and is not cancelled, reject\n        if (existingTx.to != address(0)) {\n            if (!existingTx.cancelled) revert TransactionAlreadyExists();\n            // If cancelled, we'll overwrite it below (treat as new proposal)\n            isOverwritingCancelled = true;\n        }\n\n        // If overwriting a cancelled transaction, clear all existing approvals\n        // This is necessary because approveTransaction checks if an owner has already approved\n        if (isOverwritingCancelled) {\n            for (uint256 i = 0; i < owners.length; i++) {\n                approvals[txHash][owners[i]] = false;\n            }\n        }\n\n        // Create or overwrite transaction (if it was cancelled)\n        transactions[txHash] = Transaction({\n            to: to,\n            value: value,\n            data: data,\n            executed: false,\n            cancelled: false,\n            numApprovals: 0,\n            timestamp: block.timestamp,\n            proposer: msg.sender\n        });\n\n        // Increment nonce on proposal to prevent hash collisions\n        // This ensures each proposal gets a unique hash even if cancelled and re-proposed\n        nonce++;\n\n        emit TransactionProposed(txHash, msg.sender, to, value, data);\n\n        return txHash;\n    }\n\n    /**\n     * @notice Approve a pending transaction\n     * @param txHash Transaction hash to approve\n     */\n    function approveTransaction(bytes32 txHash)\n        external\n        onlyOwner\n        txExists(txHash)\n        notExecuted(txHash)\n        notCancelled(txHash)\n    {\n        if (approvals[txHash][msg.sender]) revert AlreadyApproved();\n\n        approvals[txHash][msg.sender] = true;\n        transactions[txHash].numApprovals++;\n\n        emit TransactionApproved(txHash, msg.sender);\n    }\n\n    /**\n     * @notice Approve and execute a transaction in one call if threshold is met\n     * @dev Prevents frontrunning by combining approval and execution atomically\n     * @param txHash Transaction hash to approve and potentially execute\n     * @return executed Whether the transaction was executed\n     */\n    function approveAndExecute(bytes32 txHash)\n        external\n        onlyOwner\n        txExists(txHash)\n        notExecuted(txHash)\n        notCancelled(txHash)\n        nonReentrant\n        returns (bool executed)\n    {\n        // First, approve if not already approved\n        if (!approvals[txHash][msg.sender]) {\n            approvals[txHash][msg.sender] = true;\n            transactions[txHash].numApprovals++;\n            emit TransactionApproved(txHash, msg.sender);\n        }\n\n        // Check if threshold is met\n        Transaction storage transaction = transactions[txHash];\n        if (transaction.numApprovals >= threshold) {\n            // Execute the transaction\n            transaction.executed = true;\n\n            // Handle self-calls (owner management) differently\n            if (transaction.to == address(this)) {\n                bytes4 selector = bytes4(transaction.data);\n\n                if (selector == this.addOwner.selector) {\n                    bytes memory dataSlice = new bytes(transaction.data.length - 4);\n                    for (uint256 i = 4; i < transaction.data.length; i++) {\n                        dataSlice[i - 4] = transaction.data[i];\n                    }\n                    address newOwner = abi.decode(dataSlice, (address));\n                    _addOwner(newOwner);\n                } else if (selector == this.removeOwner.selector) {\n                    bytes memory dataSlice = new bytes(transaction.data.length - 4);\n                    for (uint256 i = 4; i < transaction.data.length; i++) {\n                        dataSlice[i - 4] = transaction.data[i];\n                    }\n                    address ownerToRemove = abi.decode(dataSlice, (address));\n                    _removeOwner(ownerToRemove);\n                } else if (selector == this.changeThreshold.selector) {\n                    bytes memory dataSlice = new bytes(transaction.data.length - 4);\n                    for (uint256 i = 4; i < transaction.data.length; i++) {\n                        dataSlice[i - 4] = transaction.data[i];\n                    }\n                    uint256 newThreshold = abi.decode(dataSlice, (uint256));\n                    _changeThreshold(newThreshold);\n                } else {\n                    (bool success, ) = transaction.to.call{value: transaction.value}(\n                        transaction.data\n                    );\n                    if (!success) revert TransactionExecutionFailed();\n                }\n            } else {\n                (bool success, ) = transaction.to.call{value: transaction.value}(\n                    transaction.data\n                );\n                if (!success) revert TransactionExecutionFailed();\n            }\n\n            emit TransactionExecuted(txHash, msg.sender);\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * @notice Execute a transaction after threshold is met\n     * @param txHash Transaction hash to execute\n     */\n    function executeTransaction(bytes32 txHash)\n        external\n        onlyOwner\n        txExists(txHash)\n        notExecuted(txHash)\n        notCancelled(txHash)\n        nonReentrant\n    {\n        Transaction storage transaction = transactions[txHash];\n\n        // Explicit check: cancelled transactions cannot be executed\n        // (Defense-in-depth: modifier already checks this, but explicit for clarity)\n        if (transaction.cancelled) revert TransactionHasBeenCancelled();\n\n        if (transaction.numApprovals < threshold) revert NotEnoughApprovals();\n\n        transaction.executed = true;\n\n        // Handle self-calls (owner management) differently to avoid reentrancy guard issues\n        if (transaction.to == address(this)) {\n            // For self-calls, decode and execute using internal functions\n            // This avoids the reentrancy guard blocking external calls\n            bytes4 selector = bytes4(transaction.data);\n            \n            if (selector == this.addOwner.selector) {\n                // Decode addOwner(address)\n                bytes memory dataSlice = new bytes(transaction.data.length - 4);\n                for (uint256 i = 4; i < transaction.data.length; i++) {\n                    dataSlice[i - 4] = transaction.data[i];\n                }\n                address newOwner = abi.decode(dataSlice, (address));\n                _addOwner(newOwner);\n            } else if (selector == this.removeOwner.selector) {\n                // Decode removeOwner(address)\n                bytes memory dataSlice = new bytes(transaction.data.length - 4);\n                for (uint256 i = 4; i < transaction.data.length; i++) {\n                    dataSlice[i - 4] = transaction.data[i];\n                }\n                address ownerToRemove = abi.decode(dataSlice, (address));\n                _removeOwner(ownerToRemove);\n            } else if (selector == this.changeThreshold.selector) {\n                // Decode changeThreshold(uint256)\n                bytes memory dataSlice = new bytes(transaction.data.length - 4);\n                for (uint256 i = 4; i < transaction.data.length; i++) {\n                    dataSlice[i - 4] = transaction.data[i];\n                }\n                uint256 newThreshold = abi.decode(dataSlice, (uint256));\n                _changeThreshold(newThreshold);\n            } else {\n                // Unknown self-call function - try using call anyway\n                (bool success, ) = transaction.to.call{value: transaction.value}(\n                    transaction.data\n                );\n                if (!success) revert TransactionExecutionFailed();\n            }\n        } else {\n            // External call - use standard call mechanism\n            (bool success, ) = transaction.to.call{value: transaction.value}(\n                transaction.data\n            );\n            if (!success) revert TransactionExecutionFailed();\n        }\n\n        emit TransactionExecuted(txHash, msg.sender);\n    }\n\n    /**\n     * @notice Revoke approval for a pending transaction\n     * @param txHash Transaction hash\n     */\n    function revokeApproval(bytes32 txHash)\n        external\n        onlyOwner\n        txExists(txHash)\n        notExecuted(txHash)\n        notCancelled(txHash)\n    {\n        if (!approvals[txHash][msg.sender]) revert NotApproved();\n\n        approvals[txHash][msg.sender] = false;\n        transactions[txHash].numApprovals--;\n\n        emit ApprovalRevoked(txHash, msg.sender);\n    }\n\n    /**\n     * @notice Cancel a pending transaction\n     * @dev Can be cancelled by the proposer immediately, or by threshold approvals\n     * @param txHash Transaction hash to cancel\n     */\n    function cancelTransaction(bytes32 txHash)\n        external\n        onlyOwner\n        txExists(txHash)\n        notExecuted(txHash)\n        notCancelled(txHash)\n    {\n        Transaction storage transaction = transactions[txHash];\n\n        // Check if caller is the proposer\n        bool isProposer = transaction.proposer == msg.sender;\n\n        // If not proposer, require threshold approvals\n        if (!isProposer) {\n            if (transaction.numApprovals < threshold) revert NotProposerAndNotEnoughApprovalsToCancel();\n        }\n\n        // Mark as cancelled\n        transaction.cancelled = true;\n\n        // Clear all approvals (clean up state)\n        // Note: We don't need to iterate through all owners since approvals mapping\n        // will just be ignored for cancelled transactions, but we reset numApprovals\n        // for clarity and potential gas savings in future reads\n        transaction.numApprovals = 0;\n\n        emit TransactionCancelled(txHash, msg.sender);\n    }\n\n    /**\n     * @notice Internal function to add a new owner\n     * @param owner Address of new owner\n     */\n    function _addOwner(address owner) internal {\n        if (owner == address(0)) revert InvalidOwnerAddress();\n        if (isOwner[owner]) revert AlreadyAnOwner();\n        if (owners.length >= MAX_OWNERS) revert MaxOwnersReached();\n\n        isOwner[owner] = true;\n        owners.push(owner);\n\n        emit OwnerAdded(owner);\n    }\n\n    /**\n     * @notice Add a new owner (requires multisig approval)\n     * @param owner Address of new owner\n     */\n    function addOwner(address owner) external onlySelf {\n        _addOwner(owner);\n    }\n\n    /**\n     * @notice Internal function to remove an owner\n     * @param owner Address of owner to remove\n     */\n    function _removeOwner(address owner) internal {\n        if (!isOwner[owner]) revert NotAnOwner();\n        if (owners.length - 1 < threshold) revert CannotRemoveOwnerWouldFallBelowThreshold();\n\n        isOwner[owner] = false;\n\n        // Remove from owners array\n        for (uint256 i = 0; i < owners.length; i++) {\n            if (owners[i] == owner) {\n                owners[i] = owners[owners.length - 1];\n                owners.pop();\n                break;\n            }\n        }\n\n        emit OwnerRemoved(owner);\n    }\n\n    /**\n     * @notice Remove an owner (requires multisig approval)\n     * @param owner Address of owner to remove\n     */\n    function removeOwner(address owner) external onlySelf {\n        _removeOwner(owner);\n    }\n\n    /**\n     * @notice Internal function to change the approval threshold\n     * @param _threshold New threshold value\n     */\n    function _changeThreshold(uint256 _threshold) internal {\n        if (_threshold == 0 || _threshold > owners.length) revert InvalidThreshold();\n\n        threshold = _threshold;\n\n        emit ThresholdChanged(_threshold);\n    }\n\n    /**\n     * @notice Change the approval threshold (requires multisig approval)\n     * @param _threshold New threshold value\n     */\n    function changeThreshold(uint256 _threshold) external onlySelf {\n        _changeThreshold(_threshold);\n    }\n\n    /**\n     * @notice Enable a module\n     * @param module Module address to enable\n     */\n    function enableModule(address module) external onlySelf {\n        if (module == address(0)) revert InvalidModuleAddress();\n        if (modules[module]) revert ModuleAlreadyEnabled();\n\n        modules[module] = true;\n\n        emit ModuleEnabled(module);\n    }\n\n    /**\n     * @notice Disable a module\n     * @param module Module address to disable\n     */\n    function disableModule(address module) external onlySelf {\n        if (!modules[module]) revert ModuleNotEnabled();\n\n        modules[module] = false;\n\n        emit ModuleDisabled(module);\n    }\n\n    /**\n     * @notice Execute transaction from authorized module\n     * @dev Modules cannot call enableModule/disableModule (prevents privilege escalation)\n     *      Owner management functions (addOwner, removeOwner, changeThreshold) are allowed\n     *      for legitimate use cases like social recovery\n     * @param to Destination address\n     * @param value Amount to send\n     * @param data Transaction data\n     * @return success True if the transaction succeeded, false otherwise\n     */\n    function execTransactionFromModule(\n        address to,\n        uint256 value,\n        bytes memory data\n    ) external onlyModule nonReentrant returns (bool) {\n        if (to == address(0)) revert InvalidDestinationAddress();\n\n        // Security: Prevent modules from modifying module permissions\n        // This prevents a compromised module from enabling/disabling other modules\n        // Owner management functions ARE allowed for legitimate recovery scenarios\n        if (to == address(this) && data.length >= 4) {\n            bytes4 selector = bytes4(data);\n            if (selector == this.enableModule.selector || selector == this.disableModule.selector) {\n                revert ModuleCannotModifyModulePermissions();\n            }\n        }\n\n        (bool success, ) = to.call{value: value}(data);\n        return success;\n    }\n\n    /**\n     * @notice Get transaction hash\n     * @param to Destination address\n     * @param value Amount\n     * @param data Transaction data\n     * @param _nonce Nonce value\n     * @return Unique bytes32 hash computed from wallet address, transaction parameters, nonce, and chain ID\n     */\n    function getTransactionHash(\n        address to,\n        uint256 value,\n        bytes memory data,\n        uint256 _nonce\n    ) public view returns (bytes32) {\n        return keccak256(\n            abi.encodePacked(\n                address(this),\n                to,\n                value,\n                data,\n                _nonce,\n                block.chainid\n            )\n        );\n    }\n\n    /**\n     * @notice Get all owners\n     * @return Array of owner addresses\n     */\n    function getOwners() external view returns (address[] memory) {\n        return owners;\n    }\n\n    /**\n     * @notice Get owner count\n     * @return Number of owners\n     */\n    function getOwnerCount() external view returns (uint256) {\n        return owners.length;\n    }\n\n    /**\n     * @notice Get transaction details\n     * @param txHash Transaction hash\n     * @return Transaction struct\n     */\n    function getTransaction(bytes32 txHash)\n        external\n        view\n        returns (Transaction memory)\n    {\n        return transactions[txHash];\n    }\n\n    /**\n     * @notice Check if address has approved transaction\n     * @param txHash Transaction hash\n     * @param owner Owner address\n     * @return True if approved\n     */\n    function hasApproved(bytes32 txHash, address owner)\n        external\n        view\n        returns (bool)\n    {\n        return approvals[txHash][owner];\n    }\n\n    /**\n     * @notice Receive function to accept Quai\n     */\n    receive() external payable {\n        emit Received(msg.sender, msg.value);\n    }\n\n    /**\n     * @notice Fallback function\n     */\n    fallback() external payable {\n        emit Received(msg.sender, msg.value);\n    }\n}\n","keccak256":"0xd793edd4525ca34439ef17a481c0967a67a853428f563e9ed0c5d0ea67c329c2","license":"MIT"}},"version":1}